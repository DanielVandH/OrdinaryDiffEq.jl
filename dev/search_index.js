var documenterSearchIndex = {"docs":
[{"location":"nonstiff/explicitrk/#Explicit-Runge-Kutta-Methods","page":"Explicit Runge-Kutta Methods","title":"Explicit Runge-Kutta Methods","text":"","category":"section"},{"location":"nonstiff/explicitrk/","page":"Explicit Runge-Kutta Methods","title":"Explicit Runge-Kutta Methods","text":"With the help of FastBroadcast.jl,  we can use threaded parallelism to reduce compute time for all of the explicit Runge-Kutta methods! The thread option determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads  (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.  When we call solve(prob, alg(thread=OrdinaryDiffEq.True())), we can turn on the multithreading option to achieve acceleration (for sufficiently large problems).","category":"page"},{"location":"nonstiff/explicitrk/#Standard-Explicit-Runge-Kutta-Methods","page":"Explicit Runge-Kutta Methods","title":"Standard Explicit Runge-Kutta Methods","text":"","category":"section"},{"location":"nonstiff/explicitrk/","page":"Explicit Runge-Kutta Methods","title":"Explicit Runge-Kutta Methods","text":"Heun\r\nRalston\r\nMidpoint\r\nRK4\r\nRKM\r\nMSRK5\r\nMSRK6\r\nAnas5\r\nRKO65\r\nOwrenZen3\r\nOwrenZen4\r\nOwrenZen5\r\nBS3\r\nDP5\r\nTsit5\r\nDP8\r\nTanYam7\r\nTsitPap8\r\nFeagin10\r\nFeagin12\r\nFeagin14\r\nFRK65\r\nPFRK87\r\nStepanov5\r\nSIR54\r\nAlshina2\r\nAlshina3\r\nAlshina6","category":"page"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Heun","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Heun","text":"Heun(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n       step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n       thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method The second order Heun's method. Uses embedded Euler method for adaptivity.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Ralston","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Ralston","text":"Ralston(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method The optimized second order midpoint method. Uses embedded Euler method for adaptivity.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Midpoint","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Midpoint","text":"Ralston(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method The second order midpoint method. Uses embedded Euler method for adaptivity.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.RK4","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.RK4","text":"RK4(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method The canonical Runge-Kutta Order 4 method. Uses a defect control for adaptive stepping using maximum error over the whole interval.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\n@article{shampine2005solving,   title={Solving ODEs and DDEs with residual control},   author={Shampine, LF},   journal={Applied Numerical Mathematics},   volume={52},   number={1},   pages={113–127},   year={2005},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.MSRK5","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.MSRK5","text":"MSRK5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\n5th order Explicit RK method.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\nMisha Stepanov - https://arxiv.org/pdf/2202.08443.pdf : Figure 3.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.MSRK6","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.MSRK6","text":"MSRK6(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\n6th order Explicit RK method.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\nMisha Stepanov - https://arxiv.org/pdf/2202.08443.pdf : Table 4.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Anas5","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Anas5","text":"Anas5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method   4th order Runge-Kutta method designed for periodic problems.   Requires a periodicity estimate, which when accurate the method becomes 5th order (and is otherwise 4th order with less error for better estimates).\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.RKO65","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.RKO65","text":"RKO65(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nA fifth-order six-stage explicit Runge-Kutta method.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\nTsitouras, Ch. \"Explicit Runge–Kutta methods for starting integration of Lane–Emden problem.\" Applied Mathematics and Computation 354 (2019): 353-364. doi: https://doi.org/10.1016/j.amc.2019.02.047\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.OwrenZen3","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.OwrenZen3","text":"OwrenZen3(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method   Owren-Zennaro optimized interpolation 3/2 method (free 3rd order interpolant).\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\n@article{owren1992derivation,   title={Derivation of efficient, continuous, explicit Runge–Kutta methods},   author={Owren, Brynjulf and Zennaro, Marino},   journal={SIAM journal on scientific and statistical computing},   volume={13},   number={6},   pages={1488–1501},   year={1992},   publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.OwrenZen4","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.OwrenZen4","text":"OwrenZen4(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method   Owren-Zennaro optimized interpolation 4/3 method (free 4th order interpolant).\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\n@article{owren1992derivation,   title={Derivation of efficient, continuous, explicit Runge–Kutta methods},   author={Owren, Brynjulf and Zennaro, Marino},   journal={SIAM journal on scientific and statistical computing},   volume={13},   number={6},   pages={1488–1501},   year={1992},   publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.OwrenZen5","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.OwrenZen5","text":"OwrenZen5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method   Owren-Zennaro optimized interpolation 5/4 method (free 5th order interpolant).\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\n@article{owren1992derivation,   title={Derivation of efficient, continuous, explicit Runge–Kutta methods},   author={Owren, Brynjulf and Zennaro, Marino},   journal={SIAM journal on scientific and statistical computing},   volume={13},   number={6},   pages={1488–1501},   year={1992},   publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.BS3","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.BS3","text":"BS3(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      thread = OrdinaryDiffEq.False())\n\nA third-order, four-stage explicit FSAL Runge-Kutta method with embedded error estimator of Bogacki and Shampine.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{bogacki19893,   title={A 3 (2) pair of Runge-Kutta formulas},   author={Bogacki, Przemyslaw and Shampine, Lawrence F},   journal={Applied Mathematics Letters},   volume={2},   number={4},   pages={321–325},   year={1989},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.DP5","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.DP5","text":"DP5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method   Dormand-Prince's 5/4 Runge-Kutta method. (free 4th order interpolant).\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\n@article{dormand1980family,   title={A family of embedded Runge-Kutta formulae},   author={Dormand, John R and Prince, Peter J},   journal={Journal of computational and applied mathematics},   volume={6},   number={1},   pages={19–26},   year={1980},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Tsit5","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Tsit5","text":"Tsit5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False())\n\nA fifth-order explicit Runge-Kutta method with embedded error estimator of Tsitouras. Free 4th order interpolant.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{tsitouras2011runge,   title={Runge–Kutta pairs of order 5 (4) satisfying only the first column simplifying assumption},   author={Tsitouras, Ch},   journal={Computers \\& Mathematics with Applications},   volume={62},   number={2},   pages={770–775},   year={2011},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.DP8","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.DP8","text":"DP8(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method   Hairer's 8/5/3 adaption of the Dormand-Prince Runge-Kutta method. (7th order interpolant).\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I. Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics, Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.TanYam7","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.TanYam7","text":"TanYam7(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method   Tanaka-Yamashita 7 Runge-Kutta method.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\nTanaka M., Muramatsu S., Yamashita S., (1992), On the Optimization of Some Nine-Stage Seventh-order Runge-Kutta Method, Information Processing Society of Japan, 33 (12), pp. 1512-1526.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.TsitPap8","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.TsitPap8","text":"TsitPap8(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method   Tsitouras-Papakostas 8/7 Runge-Kutta method.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Feagin10","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Feagin10","text":"@article{feagin2012high,   title={High-order explicit Runge-Kutta methods using m-symmetry},   author={Feagin, Terry},   year={2012},   publisher={Neural, Parallel \\& Scientific Computations} }\n\nFeagin10: Explicit Runge-Kutta Method    Feagin's 10th-order Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Feagin12","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Feagin12","text":"@article{feagin2012high,   title={High-order explicit Runge-Kutta methods using m-symmetry},   author={Feagin, Terry},   year={2012},   publisher={Neural, Parallel \\& Scientific Computations} }\n\nFeagin12: Explicit Runge-Kutta Method    Feagin's 12th-order Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Feagin14","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Feagin14","text":"Feagin, T., “An Explicit Runge-Kutta Method of Order Fourteen,” Numerical Algorithms, 2009\n\nFeagin14: Explicit Runge-Kutta Method    Feagin's 14th-order Runge-Kutta method.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.FRK65","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.FRK65","text":"FRK65(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False(),\n         omega = 0.0)\n\nExplicit Runge-Kutta   Zero Dissipation Runge-Kutta of 6th order.   Takes an optional argument omega to for the periodicity phase, in which case this method results in zero numerical dissipation.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.PFRK87","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.PFRK87","text":"PFRK87(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False(),\n         omega = 0.0)\n\nExplicit Runge-Kutta   Phase-fitted Runge-Kutta of 8th order.   Takes an optional argument w to for the periodicity phase, in which case this method results in zero numerical dissipation.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Stepanov5","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Stepanov5","text":"Stepanov5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\n5th order Explicit RK method.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\n@article{Stepanov2021Embedded5,   title={Embedded (4, 5) pairs of explicit 7-stage Runge–Kutta methods with FSAL property},   author={Misha Stepanov},   journal={Calcolo},   year={2021},   volume={59} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.SIR54","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SIR54","text":"SIR54(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\n5th order Explicit RK method suited for SIR-type epidemic models.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\n@article{Kovalnogov2020RungeKuttaPS,   title={Runge–Kutta pairs suited for SIR‐type epidemic models},   author={Vladislav N. Kovalnogov and Theodore E. Simos and Ch. Tsitouras},   journal={Mathematical Methods in the Applied Sciences},   year={2020},   volume={44},   pages={5210 - 5216} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Alshina2","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Alshina2","text":"Alshina2(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\n2nd order, 2-stage Explicit Runge-Kutta Method with optimal parameters.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\n@article{Alshina2008,   doi = {10.1134/s0965542508030068},   url = {https://doi.org/10.1134/s0965542508030068},   year = {2008},   month = mar,   publisher = {Pleiades Publishing Ltd},   volume = {48},   number = {3},   pages = {395–405},   author = {E. A. Alshina and E. M. Zaks and N. N. Kalitkin},   title = {Optimal first- to sixth-order accurate Runge-Kutta schemes},   journal = {Computational Mathematics and Mathematical Physics} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Alshina3","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Alshina3","text":"Alshina3(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\n3rd order, 3-stage Explicit Runge-Kutta Method with optimal parameters.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\n@article{Alshina2008,   doi = {10.1134/s0965542508030068},   url = {https://doi.org/10.1134/s0965542508030068},   year = {2008},   month = mar,   publisher = {Pleiades Publishing Ltd},   volume = {48},   number = {3},   pages = {395–405},   author = {E. A. Alshina and E. M. Zaks and N. N. Kalitkin},   title = {Optimal first- to sixth-order accurate Runge-Kutta schemes},   journal = {Computational Mathematics and Mathematical Physics} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Alshina6","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Alshina6","text":"Alshina6(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\n6th order, 7-stage Explicit Runge-Kutta Method with optimal parameters.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\n@article{Alshina2008,   doi = {10.1134/s0965542508030068},   url = {https://doi.org/10.1134/s0965542508030068},   year = {2008},   month = mar,   publisher = {Pleiades Publishing Ltd},   volume = {48},   number = {3},   pages = {395–405},   author = {E. A. Alshina and E. M. Zaks and N. N. Kalitkin},   title = {Optimal first- to sixth-order accurate Runge-Kutta schemes},   journal = {Computational Mathematics and Mathematical Physics} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#Lazy-Interpolation-Explicit-Runge-Kutta-Methods","page":"Explicit Runge-Kutta Methods","title":"Lazy Interpolation Explicit Runge-Kutta Methods","text":"","category":"section"},{"location":"nonstiff/explicitrk/","page":"Explicit Runge-Kutta Methods","title":"Explicit Runge-Kutta Methods","text":"BS5\r\nVern6\r\nVern7\r\nVern8\r\nVern9","category":"page"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.BS5","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.BS5","text":"BS5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False(),\n         lazy = true)\n\nExplicit Runge-Kutta Method   Bogacki-Shampine 5/4 Runge-Kutta method. (lazy 5th order interpolant).\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\n@article{bogacki1996efficient,   title={An efficient runge-kutta (4, 5) pair},   author={Bogacki, P and Shampine, Lawrence F},   journal={Computers \\& Mathematics with Applications},   volume={32},   number={6},   pages={15–28},   year={1996},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Vern6","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Vern6","text":"Vern6(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False(),\n         lazy = true)\n\nExplicit Runge-Kutta Method   Verner's “Most Efficient” 6/5 Runge-Kutta method. (lazy 6th order interpolant).\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\n@article{verner2010numerically,   title={Numerically optimal Runge–Kutta pairs with interpolants},   author={Verner, James H},   journal={Numerical Algorithms},   volume={53},   number={2-3},   pages={383–396},   year={2010},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Vern7","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Vern7","text":"Vern7(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method   Verner's “Most Efficient” 7/6 Runge-Kutta method. (lazy 7th order interpolant).\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\n@article{verner2010numerically,   title={Numerically optimal Runge–Kutta pairs with interpolants},   author={Verner, James H},   journal={Numerical Algorithms},   volume={53},   number={2-3},   pages={383–396},   year={2010},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Vern8","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Vern8","text":"Vern8(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False(),\n         lazy = true)\n\nExplicit Runge-Kutta Method   Verner's “Most Efficient” 8/7 Runge-Kutta method. (lazy 8th order interpolant)\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\n@article{verner2010numerically,   title={Numerically optimal Runge–Kutta pairs with interpolants},   author={Verner, James H},   journal={Numerical Algorithms},   volume={53},   number={2-3},   pages={383–396},   year={2010},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Vern9","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Vern9","text":"Vern9(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False(),\n         lazy = true)\n\nExplicit Runge-Kutta Method   Verner's “Most Efficient” 9/8 Runge-Kutta method. (lazy 9th order interpolant)\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\n@article{verner2010numerically,   title={Numerically optimal Runge–Kutta pairs with interpolants},   author={Verner, James H},   journal={Numerical Algorithms},   volume={53},   number={2-3},   pages={383–396},   year={2010},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#Fixed-Timestep-Only-Explicit-Runge-Kutta-Methods","page":"Explicit Runge-Kutta Methods","title":"Fixed Timestep Only Explicit Runge-Kutta Methods","text":"","category":"section"},{"location":"nonstiff/explicitrk/","page":"Explicit Runge-Kutta Methods","title":"Explicit Runge-Kutta Methods","text":"Euler\r\nRK46NL\r\nORK256","category":"page"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.Euler","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.Euler","text":"Euler - The canonical forward Euler method. Fixed timestep only.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.RK46NL","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.RK46NL","text":"RK46NL(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\n6-stage, fourth order low-stage, low-dissipation, low-dispersion scheme. Fixed timestep only.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\nJulien Berland, Christophe Bogey, Christophe Bailly. Low-Dissipation and Low-Dispersion Fourth-Order Runge-Kutta Algorithm. Computers & Fluids, 35(10), pp 1459-1463, 2006. doi: https://doi.org/10.1016/j.compfluid.2005.04.003\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.ORK256","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.ORK256","text":"ORK256(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False(),\n         williamson_condition = true)\n\nA second-order, five-stage explicit Runge-Kutta method for wave propagation equations. Fixed timestep only.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nMatteo Bernardini, Sergio Pirozzoli. A General Strategy for the Optimization of Runge-Kutta Schemes for Wave Propagation Phenomena. Journal of Computational Physics, 228(11), pp 4182-4199, 2009. doi: https://doi.org/10.1016/j.jcp.2009.02.032\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicitrk/#Parallel-Explicit-Runge-Kutta-Methods","page":"Explicit Runge-Kutta Methods","title":"Parallel Explicit Runge-Kutta Methods","text":"","category":"section"},{"location":"nonstiff/explicitrk/","page":"Explicit Runge-Kutta Methods","title":"Explicit Runge-Kutta Methods","text":"KuttaPRK2p5","category":"page"},{"location":"nonstiff/explicitrk/#OrdinaryDiffEq.KuttaPRK2p5","page":"Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.KuttaPRK2p5","text":"KuttaPRK2p5: Parallel Explicit Runge-Kutta Method   A 5 parallel, 2 processor explicit Runge-Kutta method of 5th order.\n\nThese methods utilize multithreading on the f calls to parallelize the problem.   This requires that simultaneous calls to f are thread-safe.\n\n\n\n\n\n","category":"type"},{"location":"semilinear/magnus/#Magnus-and-Lie-Group-Integrators","page":"Magnus and Lie Group Integrators","title":"Magnus and Lie Group Integrators","text":"","category":"section"},{"location":"semilinear/magnus/","page":"Magnus and Lie Group Integrators","title":"Magnus and Lie Group Integrators","text":"MagnusMidpoint\r\nMagnusLeapfrog\r\nLieEuler\r\nMagnusGauss4\r\nMagnusNC6\r\nMagnusGL6\r\nMagnusGL8\r\nMagnusNC8\r\nMagnusGL4\r\nRKMK2\r\nRKMK4\r\nLieRK4\r\nCG2\r\nCG3\r\nCG4a\r\nMagnusAdapt4\r\nCayleyEuler","category":"page"},{"location":"stiff/stiff_multistep/#Multistep-Methods-for-Stiff-Equations","page":"Multistep Methods for Stiff Equations","title":"Multistep Methods for Stiff Equations","text":"","category":"section"},{"location":"stiff/stiff_multistep/","page":"Multistep Methods for Stiff Equations","title":"Multistep Methods for Stiff Equations","text":"QNDF1\r\nQBDF1\r\nQNDF2\r\nQBDF2\r\nABDF2\r\nQNDF\r\nQBDF\r\nFBDF\r\nMEBDF2","category":"page"},{"location":"stiff/stiff_multistep/#OrdinaryDiffEq.QNDF1","page":"Multistep Methods for Stiff Equations","title":"OrdinaryDiffEq.QNDF1","text":"QNDF1: Multistep Method   An adaptive order 1 quasi-constant timestep L-stable numerical differentiation function (NDF) method.   Optional parameter kappa defaults to Shampine's accuracy-optimal -0.1850.\n\nSee also QNDF.\n\n\n\n\n\n","category":"type"},{"location":"stiff/stiff_multistep/#OrdinaryDiffEq.QBDF1","page":"Multistep Methods for Stiff Equations","title":"OrdinaryDiffEq.QBDF1","text":"QBDF1: Multistep Method\n\nAn alias of QNDF1 with κ=0.\n\n\n\n\n\n","category":"function"},{"location":"stiff/stiff_multistep/#OrdinaryDiffEq.QNDF2","page":"Multistep Methods for Stiff Equations","title":"OrdinaryDiffEq.QNDF2","text":"QNDF2: Multistep Method   An adaptive order 2 quasi-constant timestep L-stable numerical differentiation function (NDF) method.\n\nSee also QNDF.\n\n\n\n\n\n","category":"type"},{"location":"stiff/stiff_multistep/#OrdinaryDiffEq.QBDF2","page":"Multistep Methods for Stiff Equations","title":"OrdinaryDiffEq.QBDF2","text":"QBDF2: Multistep Method\n\nAn alias of QNDF2 with κ=0.\n\n\n\n\n\n","category":"function"},{"location":"stiff/stiff_multistep/#OrdinaryDiffEq.ABDF2","page":"Multistep Methods for Stiff Equations","title":"OrdinaryDiffEq.ABDF2","text":"E. Alberdi Celayaa, J. J. Anza Aguirrezabalab, P. Chatzipantelidisc. Implementation of an Adaptive BDF2 Formula and Comparison with The MATLAB Ode15s. Procedia Computer Science, 29, pp 1014-1026, 2014. doi: https://doi.org/10.1016/j.procs.2014.05.091\n\nABDF2: Multistep Method   An adaptive order 2 L-stable fixed leading coefficient multistep BDF method.\n\n\n\n\n\n","category":"type"},{"location":"stiff/stiff_multistep/#OrdinaryDiffEq.QNDF","page":"Multistep Methods for Stiff Equations","title":"OrdinaryDiffEq.QNDF","text":"QNDF: Multistep Method   An adaptive order quasi-constant timestep NDF method.   Utilizes Shampine's accuracy-optimal kappa values as defaults (has a keyword argument for a tuple of kappa coefficients).\n\n@article{shampine1997matlab,   title={The matlab ode suite},   author={Shampine, Lawrence F and Reichelt, Mark W},   journal={SIAM journal on scientific computing},   volume={18},   number={1},   pages={1–22},   year={1997},   publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"stiff/stiff_multistep/#OrdinaryDiffEq.QBDF","page":"Multistep Methods for Stiff Equations","title":"OrdinaryDiffEq.QBDF","text":"QBDF: Multistep Method\n\nAn alias of QNDF with κ=0.\n\n\n\n\n\n","category":"function"},{"location":"stiff/stiff_multistep/#OrdinaryDiffEq.FBDF","page":"Multistep Methods for Stiff Equations","title":"OrdinaryDiffEq.FBDF","text":"FBDF: Fixed leading coefficient BDF\n\nAn adaptive order quasi-constant timestep NDF method. Utilizes Shampine's accuracy-optimal kappa values as defaults (has a keyword argument for a tuple of kappa coefficients).\n\n@article{shampine2002solving,   title={Solving 0= F (t, y (t), y′(t)) in Matlab},   author={Shampine, Lawrence F},   year={2002},   publisher={Walter de Gruyter GmbH \\& Co. KG} }\n\n\n\n\n\n","category":"type"},{"location":"stiff/stiff_multistep/#OrdinaryDiffEq.MEBDF2","page":"Multistep Methods for Stiff Equations","title":"OrdinaryDiffEq.MEBDF2","text":"MEBDF2: Multistep Method   The second order Modified Extended BDF method, which has improved stability properties over the standard BDF.   Fixed timestep only.\n\n\n\n\n\n","category":"type"},{"location":"dae/fully_implicit/#Methods-for-Fully-Implicit-ODEs-(DAEProblem)","page":"Methods for Fully Implicit ODEs (DAEProblem)","title":"Methods for Fully Implicit ODEs (DAEProblem)","text":"","category":"section"},{"location":"dae/fully_implicit/","page":"Methods for Fully Implicit ODEs (DAEProblem)","title":"Methods for Fully Implicit ODEs (DAEProblem)","text":"DImplicitEuler\r\nDABDF2\r\nDFBDF","category":"page"},{"location":"nonstiff/lowstorage_ssprk/#PDE-Specialized-Explicit-Runge-Kutta-Methods","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"PDE-Specialized Explicit Runge-Kutta Methods","text":"","category":"section"},{"location":"nonstiff/lowstorage_ssprk/#Low-Storage-Explicit-Runge-Kutta-Methods","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"Low Storage Explicit Runge-Kutta Methods","text":"","category":"section"},{"location":"nonstiff/lowstorage_ssprk/","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"PDE-Specialized Explicit Runge-Kutta Methods","text":"CarpenterKennedy2N54\r\nSHLDDRK64\r\nSHLDDRK52\r\nSHLDDRK_2N\r\nHSLDDRK64\r\nDGLDDRK73_C\r\nDGLDDRK84_C\r\nDGLDDRK84_F\r\nNDBLSRK124\r\nNDBLSRK134\r\nNDBLSRK144\r\nCFRLDDRK64\r\nTSLDDRK74\r\nCKLLSRK43_2\r\nCKLLSRK54_3C\r\nCKLLSRK95_4S\r\nCKLLSRK95_4C\r\nCKLLSRK95_4M\r\nCKLLSRK54_3C_3R\r\nCKLLSRK54_3M_3R\r\nCKLLSRK54_3N_3R\r\nCKLLSRK85_4C_3R\r\nCKLLSRK85_4M_3R\r\nCKLLSRK85_4P_3R\r\nCKLLSRK54_3N_4R\r\nCKLLSRK54_3M_4R\r\nCKLLSRK65_4M_4R\r\nCKLLSRK85_4FM_4R\r\nCKLLSRK75_4M_5R\r\nParsaniKetchesonDeconinck3S32\r\nParsaniKetchesonDeconinck3S82\r\nParsaniKetchesonDeconinck3S53\r\nParsaniKetchesonDeconinck3S173\r\nParsaniKetchesonDeconinck3S94\r\nParsaniKetchesonDeconinck3S184\r\nParsaniKetchesonDeconinck3S105\r\nParsaniKetchesonDeconinck3S205\r\nRDPK3Sp35\r\nRDPK3SpFSAL35\r\nRDPK3Sp49\r\nRDPK3SpFSAL49\r\nRDPK3Sp510\r\nRDPK3SpFSAL510","category":"page"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CarpenterKennedy2N54","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CarpenterKennedy2N54","text":"CarpenterKennedy2N54(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                       step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                       thread = OrdinaryDiffEq.False(),\n                       williamson_condition = true)\n\nA fourth-order, five-stage explicit low-storage method of Carpenter and Kennedy (free 3rd order Hermite interpolant). Fixed timestep only. Designed for hyperbolic PDEs (stability properties).\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{carpenter1994fourth,   title={Fourth-order 2N-storage Runge-Kutta schemes},   author={Carpenter, Mark H and Kennedy, Christopher A},   year={1994} }\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SHLDDRK64","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SHLDDRK64","text":"SHLDDRK64(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False(),\n            williamson_condition = true)\n\nA fourth-order, six-stage explicit low-storage method. Fixed timestep only.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nD. Stanescu, W. G. Habashi. 2N-Storage Low Dissipation and Dispersion Runge-Kutta Schemes for Computational Acoustics. Journal of Computational Physics, 143(2), pp 674-681, 1998. doi: https://doi.org/10.1006/jcph.1998.5986\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.HSLDDRK64","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.HSLDDRK64","text":"HSLDDRK64(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method 6-stage, fourth order low-stage, low-dissipation, low-dispersion scheme. Fixed timestep only.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.DGLDDRK73_C","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.DGLDDRK73_C","text":"DGLDDRK73_C(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False(),\n              williamson_condition = true)\n\n7-stage, third order low-storage low-dissipation, low-dispersion scheme for discontinuous Galerkin space discretizations applied to wave propagation problems. Optimized for PDE discretizations when maximum spatial step is small due to geometric features of computational domain. Fixed timestep only.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nT. Toulorge, W. Desmet. Optimal Runge–Kutta Schemes for Discontinuous Galerkin Space Discretizations Applied to Wave Propagation Problems. Journal of Computational Physics, 231(4), pp 2067-2091, 2012. doi: https://doi.org/10.1016/j.jcp.2011.11.024\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.DGLDDRK84_C","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.DGLDDRK84_C","text":"DGLDDRK84_C(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False(),\n              williamson_condition = true)\n\n8-stage, fourth order low-storage low-dissipation, low-dispersion scheme for discontinuous Galerkin space discretizations applied to wave propagation problems. Optimized for PDE discretizations when maximum spatial step is small due to geometric features of computational domain. Fixed timestep only.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nT. Toulorge, W. Desmet. Optimal Runge–Kutta Schemes for Discontinuous Galerkin Space Discretizations Applied to Wave Propagation Problems. Journal of Computational Physics, 231(4), pp 2067-2091, 2012. doi: https://doi.org/10.1016/j.jcp.2011.11.024\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.DGLDDRK84_F","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.DGLDDRK84_F","text":"DGLDDRK84_F(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False(),\n              williamson_condition = true)\n\n8-stage, fourth order low-storage low-dissipation, low-dispersion scheme for discontinuous Galerkin space discretizations applied to wave propagation problems. Optimized for PDE discretizations when the maximum spatial step size is not constrained. Fixed timestep only.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nT. Toulorge, W. Desmet. Optimal Runge–Kutta Schemes for Discontinuous Galerkin Space Discretizations Applied to Wave Propagation Problems. Journal of Computational Physics, 231(4), pp 2067-2091, 2012. doi: https://doi.org/10.1016/j.jcp.2011.11.024\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.NDBLSRK124","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.NDBLSRK124","text":"NDBLSRK124(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False(),\n             williamson_condition = true)\n\n12-stage, fourth order low-storage method with optimized stability regions for advection-dominated problems. Fixed timestep only.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nJens Niegemann, Richard Diehl, Kurt Busch. Efficient Low-Storage Runge–Kutta Schemes with Optimized Stability Regions. Journal of Computational Physics, 231, pp 364-372, 2012. doi: https://doi.org/10.1016/j.jcp.2011.09.003\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.NDBLSRK134","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.NDBLSRK134","text":"NDBLSRK134(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False(),\n             williamson_condition = true)\n\n13-stage, fourth order low-storage method with optimized stability regions for advection-dominated problems. Fixed timestep only.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nJens Niegemann, Richard Diehl, Kurt Busch. Efficient Low-Storage Runge–Kutta Schemes with Optimized Stability Regions. Journal of Computational Physics, 231, pp 364-372, 2012. doi: https://doi.org/10.1016/j.jcp.2011.09.003\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.NDBLSRK144","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.NDBLSRK144","text":"NDBLSRK144(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False(),\n             williamson_condition = true)\n\n14-stage, fourth order low-storage method with optimized stability regions for advection-dominated problems. Fixed timestep only.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nJens Niegemann, Richard Diehl, Kurt Busch. Efficient Low-Storage Runge–Kutta Schemes with Optimized Stability Regions. Journal of Computational Physics, 231, pp 364-372, 2012. doi: https://doi.org/10.1016/j.jcp.2011.09.003\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CFRLDDRK64","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CFRLDDRK64","text":"CFRLDDRK64(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False())\n\nLow-Storage Method 6-stage, fourth order low-storage, low-dissipation, low-dispersion scheme. Fixed timestep only.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\nM. Calvo, J. M. Franco, L. Randez. A New Minimum Storage Runge–Kutta Scheme for Computational Acoustics. Journal of Computational Physics, 201, pp 1-12, 2004. doi: https://doi.org/10.1016/j.jcp.2004.05.012\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.TSLDDRK74","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.TSLDDRK74","text":"Ralston(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method 7-stage, fourth order low-storage low-dissipation, low-dispersion scheme with maximal accuracy and stability limit along the imaginary axes. Fixed timestep only.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n#Reference Kostas Tselios, T. E. Simos. Optimized Runge–Kutta Methods with Minimal Dispersion and Dissipation for Problems arising from Computational Acoustics. Physics Letters A, 393(1-2), pp 38-47, 2007. doi: https://doi.org/10.1016/j.physleta.2006.10.072\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK43_2","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK43_2","text":"CKLLSRK43_2(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   4-stage, third order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK54_3C","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK54_3C","text":"CKLLSRK54_3C(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method 5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK95_4S","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK95_4S","text":"CKLLSRK954S(; stagelimiter! = OrdinaryDiffEq.triviallimiter!,              steplimiter! = OrdinaryDiffEq.trivial_limiter!,              thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   9-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK95_4C","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK95_4C","text":"CKLLSRK95_4C(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   9-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK95_4M","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK95_4M","text":"CKLLSRK95_4M(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   9-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK54_3C_3R","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK54_3C_3R","text":"CKLLSRK54_3C_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK54_3M_3R","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK54_3M_3R","text":"CKLLSRK54_3M_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK54_3N_3R","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK54_3N_3R","text":"CKLLSRK54_3N_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK85_4C_3R","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK85_4C_3R","text":"CKLLSRK85_4M_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   8-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK85_4M_3R","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK85_4M_3R","text":"CKLLSRK85_4M_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   8-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK85_4P_3R","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK85_4P_3R","text":"CKLLSRK85_4P_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   8-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK54_3N_4R","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK54_3N_4R","text":"CKLLSRK54_3N_4R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK54_3M_4R","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK54_3M_4R","text":"CKLLSRK54_3M_4R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK65_4M_4R","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK65_4M_4R","text":"CKLLSRK65_4M_4R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\n6-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK85_4FM_4R","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK85_4FM_4R","text":"CKLLSRK85_4FM_4R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   8-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.CKLLSRK75_4M_5R","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.CKLLSRK75_4M_5R","text":"CKLLSRK754M5R: Low-Storage Method   7-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.ParsaniKetchesonDeconinck3S32","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.ParsaniKetchesonDeconinck3S32","text":"ParsaniKetchesonDeconinck3S32(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   3-stage, second order (3S) low-storage scheme, optimized  the spectral difference method applied to wave propagation problems.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck. \"Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.\" SIAM Journal on Scientific Computing 35.2 (2013): A957-A986. doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.ParsaniKetchesonDeconinck3S82","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.ParsaniKetchesonDeconinck3S82","text":"ParsaniKetchesonDeconinck3S82(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   8-stage, second order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck. \"Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.\" SIAM Journal on Scientific Computing 35.2 (2013): A957-A986. doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.ParsaniKetchesonDeconinck3S53","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.ParsaniKetchesonDeconinck3S53","text":"ParsaniKetchesonDeconinck3S53(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   5-stage, third order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck. \"Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.\" SIAM Journal on Scientific Computing 35.2 (2013): A957-A986. doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.ParsaniKetchesonDeconinck3S173","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.ParsaniKetchesonDeconinck3S173","text":"ParsaniKetchesonDeconinck3S173(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   17-stage, third order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck. \"Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.\" SIAM Journal on Scientific Computing 35.2 (2013): A957-A986. doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.ParsaniKetchesonDeconinck3S94","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.ParsaniKetchesonDeconinck3S94","text":"ParsaniKetchesonDeconinck3S94(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   9-stage, fourth order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck. \"Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.\" SIAM Journal on Scientific Computing 35.2 (2013): A957-A986. doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.ParsaniKetchesonDeconinck3S184","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.ParsaniKetchesonDeconinck3S184","text":"ParsaniKetchesonDeconinck3S184(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   18-stage, fourth order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck. \"Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.\" SIAM Journal on Scientific Computing 35.2 (2013): A957-A986. doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.ParsaniKetchesonDeconinck3S105","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.ParsaniKetchesonDeconinck3S105","text":"ParsaniKetchesonDeconinck3S105(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   10-stage, fifth order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck. \"Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.\" SIAM Journal on Scientific Computing 35.2 (2013): A957-A986. doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.ParsaniKetchesonDeconinck3S205","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.ParsaniKetchesonDeconinck3S205","text":"ParsaniKetchesonDeconinck3S205(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nLow-Storage Method   20-stage, fifth order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReference\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck. \"Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.\" SIAM Journal on Scientific Computing 35.2 (2013): A957-A986. doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.RDPK3Sp35","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.RDPK3Sp35","text":"RDPK3Sp35(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nA third-order, five-stage explicit Runge-Kutta method with embedded error estimator designed for spectral element discretizations of compressible fluid mechanics.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021) Optimized Runge-Kutta Methods with Automatic Step Size Control for Compressible Computational Fluid Dynamics arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.RDPK3SpFSAL35","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.RDPK3SpFSAL35","text":"RDPK3SpFSAL35(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                thread = OrdinaryDiffEq.False())\n\nA third-order, five-stage explicit Runge-Kutta method with embedded error estimator using the FSAL property designed for spectral element discretizations of compressible fluid mechanics.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021) Optimized Runge-Kutta Methods with Automatic Step Size Control for Compressible Computational Fluid Dynamics arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.RDPK3Sp49","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.RDPK3Sp49","text":"RDPK3Sp49(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nA fourth-order, nine-stage explicit Runge-Kutta method with embedded error estimator designed for spectral element discretizations of compressible fluid mechanics.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021) Optimized Runge-Kutta Methods with Automatic Step Size Control for Compressible Computational Fluid Dynamics arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.RDPK3SpFSAL49","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.RDPK3SpFSAL49","text":"RDPK3SpFSAL49(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                thread = OrdinaryDiffEq.False())\n\nA fourth-order, nine-stage explicit Runge-Kutta method with embedded error estimator using the FSAL property designed for spectral element discretizations of compressible fluid mechanics.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021) Optimized Runge-Kutta Methods with Automatic Step Size Control for Compressible Computational Fluid Dynamics arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.RDPK3Sp510","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.RDPK3Sp510","text":"RDPK3Sp510(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False())\n\nA fifth-order, ten-stage explicit Runge-Kutta method with embedded error estimator designed for spectral element discretizations of compressible fluid mechanics.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021) Optimized Runge-Kutta Methods with Automatic Step Size Control for Compressible Computational Fluid Dynamics arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.RDPK3SpFSAL510","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.RDPK3SpFSAL510","text":"RDPK3SpFSAL510(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                 step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                 thread = OrdinaryDiffEq.False())\n\nA fifth-order, ten-stage explicit Runge-Kutta method with embedded error estimator using the FSAL property designed for spectral element discretizations of compressible fluid mechanics.\n\nLike SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021) Optimized Runge-Kutta Methods with Automatic Step Size Control for Compressible Computational Fluid Dynamics arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#SSP-Optimized-Runge-Kutta-Methods","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"SSP Optimized Runge-Kutta Methods","text":"","category":"section"},{"location":"nonstiff/lowstorage_ssprk/","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"PDE-Specialized Explicit Runge-Kutta Methods","text":"KYK2014DGSSPRK_3S2\r\nSSPRK22\r\nSSPRK33\r\nSSPRK53\r\nKYKSSPRK42\r\nSSPRK53_2N1\r\nSSPRK53_2N2\r\nSSPRK53_H\r\nSSPRK63\r\nSSPRK73\r\nSSPRK83\r\nSSPRK43\r\nSSPRK432\r\nSSPRKMSVS43\r\nSSPRKMSVS32\r\nSSPRK932\r\nSSPRK54\r\nSSPRK104","category":"page"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRK22","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRK22","text":"SSPRK22(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nA second-order, two-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nLike all SSPRK methods, this method takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nShu, Chi-Wang, and Stanley Osher. \"Efficient implementation of essentially non-oscillatory shock-capturing schemes.\" Journal of Computational Physics 77.2 (1988): 439-471. https://doi.org/10.1016/0021-9991(88)90177-5\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRK33","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRK33","text":"SSPRK33(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nA third-order, three-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nLike all SSPRK methods, this method takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nShu, Chi-Wang, and Stanley Osher. \"Efficient implementation of essentially non-oscillatory shock-capturing schemes.\" Journal of Computational Physics 77.2 (1988): 439-471. https://doi.org/10.1016/0021-9991(88)90177-5\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRK53","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRK53","text":"SSPRK53(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nA third-order, five-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nLike all SSPRK methods, this method takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRuuth, Steven. \"Global optimization of explicit strong-stability-preserving Runge-Kutta methods.\" Mathematics of Computation 75.253 (2006): 183-207.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRK53_2N1","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRK53_2N1","text":"SSPRK53_2N1(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False())\n\nA third-order, five-stage explicit strong stability preserving (SSP) low-storage method. Fixed timestep only.\n\nLike all SSPRK methods, this method takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nHigueras and T. Roldán. \"New third order low-storage SSP explicit Runge–Kutta methods\". arXiv:1809.04807v1.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRK53_2N2","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRK53_2N2","text":"SSPRK53_2N2(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False())\n\nA third-order, five-stage explicit strong stability preserving (SSP) low-storage method. Fixed timestep only.\n\nLike all SSPRK methods, this method takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nHigueras and T. Roldán. \"New third order low-storage SSP explicit Runge–Kutta methods\". arXiv:1809.04807v1.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRK53_H","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRK53_H","text":"SSPRK53_H(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nA third-order, five-stage explicit strong stability preserving (SSP) low-storage method. Fixed timestep only.\n\nLike all SSPRK methods, this method takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nHigueras and T. Roldán. \"New third order low-storage SSP explicit Runge–Kutta methods\". arXiv:1809.04807v1.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRK63","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRK63","text":"SSPRK63(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nA third-order, six-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nLike all SSPRK methods, this method takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRuuth, Steven. \"Global optimization of explicit strong-stability-preserving Runge-Kutta methods.\" Mathematics of Computation 75.253 (2006): 183-207.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRK73","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRK73","text":"SSPRK73(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nA third-order, seven-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nLike all SSPRK methods, this method takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRuuth, Steven. \"Global optimization of explicit strong-stability-preserving Runge-Kutta methods.\" Mathematics of Computation 75.253 (2006): 183-207.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRK83","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRK83","text":"SSPRK83(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nA third-order, eight-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nLike all SSPRK methods, this method takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRuuth, Steven. \"Global optimization of explicit strong-stability-preserving Runge-Kutta methods.\" Mathematics of Computation 75.253 (2006): 183-207.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRK43","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRK43","text":"SSPRK43(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nA third-order, four-stage explicit strong stability preserving (SSP) method.\n\nLike all SSPRK methods, this method takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nOptimal third-order explicit SSP method with four stages discovered by\n\nJ. F. B. M. Kraaijevanger. \"Contractivity of Runge-Kutta methods.\" In: BIT Numerical Mathematics 31.3 (1991), pp. 482–528. DOI: 10.1007/BF01933264.\n\nEmbedded method constructed by\n\nSidafa Conde, Imre Fekete, John N. Shadid. \"Embedded error estimation and adaptive step-size control for optimal explicit strong stability preserving Runge–Kutta methods.\" arXiv: 1806.08693\n\nEfficient implementation (and optimized controller) developed by\n\nHendrik Ranocha, Lisandro Dalcin, Matteo Parsani, David I. Ketcheson (2021) Optimized Runge-Kutta Methods with Automatic Step Size Control for Compressible Computational Fluid Dynamics arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRK432","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRK432","text":"SSPRK432(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nA third-order, four-stage explicit strong stability preserving (SSP) method.\n\nConsider using SSPRK43 instead, which uses the same main method and an improved embedded method.\n\nLike all SSPRK methods, this method takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nGottlieb, Sigal, David I. Ketcheson, and Chi-Wang Shu. Strong stability preserving Runge-Kutta and multistep time discretizations. World Scientific, 2011. Example 6.1.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRKMSVS43","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRKMSVS43","text":"SSPRKMSVS43(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False())\n\nA third-order, four-step explicit strong stability preserving (SSP) linear multistep method. This method does not come with an error estimator and requires a fixed time step size.\n\nLike all SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nShu, Chi-Wang. \"Total-variation-diminishing time discretizations.\" SIAM Journal on Scientific and Statistical Computing 9, no. 6 (1988): 1073-1084. DOI: 10.1137/0909073\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRKMSVS32","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRKMSVS32","text":"SSPRKMSVS32(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False())\n\nA second-order, three-step explicit strong stability preserving (SSP) linear multistep method. This method does not come with an error estimator and requires a fixed time step size.\n\nLike all SSPRK methods, this method also takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nShu, Chi-Wang. \"Total-variation-diminishing time discretizations.\" SIAM Journal on Scientific and Statistical Computing 9, no. 6 (1988): 1073-1084. DOI: 10.1137/0909073\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRK932","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRK932","text":"SSPRK932(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nA third-order, nine-stage explicit strong stability preserving (SSP) method.\n\nConsider using SSPRK43 instead, which uses the same main method and an improved embedded method.\n\nLike all SSPRK methods, this method takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nGottlieb, Sigal, David I. Ketcheson, and Chi-Wang Shu. Strong stability preserving Runge-Kutta and multistep time discretizations. World Scientific, 2011.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRK54","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRK54","text":"SSPRK54(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nA fourth-order, five-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nLike all SSPRK methods, this method takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRuuth, Steven. \"Global optimization of explicit strong-stability-preserving Runge-Kutta methods.\" Mathematics of Computation 75.253 (2006): 183-207.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/lowstorage_ssprk/#OrdinaryDiffEq.SSPRK104","page":"PDE-Specialized Explicit Runge-Kutta Methods","title":"OrdinaryDiffEq.SSPRK104","text":"SSPRK104(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nA fourth-order, ten-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nLike all SSPRK methods, this method takes optional arguments stage_limiter! and step_limiter!, where stage_limiter! and step_limiter! are functions of the form limiter!(u, integrator, p, t).\n\nThe argument thread determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(), default) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nKetcheson, David I. \"Highly efficient strong stability-preserving Runge–Kutta methods with low-storage implementations.\" SIAM Journal on Scientific Computing 30.4 (2008): 2113-2136.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/nonstiff_multistep/#Multistep-Methods-for-Non-Stiff-Equations","page":"Multistep Methods for Non-Stiff Equations","title":"Multistep Methods for Non-Stiff Equations","text":"","category":"section"},{"location":"nonstiff/nonstiff_multistep/#Explicit-Multistep-Methods","page":"Multistep Methods for Non-Stiff Equations","title":"Explicit Multistep Methods","text":"","category":"section"},{"location":"nonstiff/nonstiff_multistep/","page":"Multistep Methods for Non-Stiff Equations","title":"Multistep Methods for Non-Stiff Equations","text":"AB3\r\nAB4\r\nAB5\r\nAN5","category":"page"},{"location":"nonstiff/nonstiff_multistep/#OrdinaryDiffEq.AB3","page":"Multistep Methods for Non-Stiff Equations","title":"OrdinaryDiffEq.AB3","text":"E. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\nAB3: Adams-Bashforth Explicit Method   The 3-step third order multistep method. Ralston's Second Order Method is used to calculate starting values.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/nonstiff_multistep/#OrdinaryDiffEq.AB4","page":"Multistep Methods for Non-Stiff Equations","title":"OrdinaryDiffEq.AB4","text":"E. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\nAB4: Adams-Bashforth Explicit Method   The 4-step fourth order multistep method. Runge-Kutta method of order 4 is used to calculate starting values.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/nonstiff_multistep/#OrdinaryDiffEq.AB5","page":"Multistep Methods for Non-Stiff Equations","title":"OrdinaryDiffEq.AB5","text":"E. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\nAB5: Adams-Bashforth Explicit Method   The 3-step third order multistep method. Ralston's Second Order Method is used to calculate starting values.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/nonstiff_multistep/#OrdinaryDiffEq.AN5","page":"Multistep Methods for Non-Stiff Equations","title":"OrdinaryDiffEq.AN5","text":"AN5: Adaptive step size Adams explicit Method   An adaptive 5th order fixed-leading coefficient Adams method in Nordsieck form.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/nonstiff_multistep/#Predictor-Corrector-Methods","page":"Multistep Methods for Non-Stiff Equations","title":"Predictor-Corrector Methods","text":"","category":"section"},{"location":"nonstiff/nonstiff_multistep/","page":"Multistep Methods for Non-Stiff Equations","title":"Multistep Methods for Non-Stiff Equations","text":"ABM32\r\nABM43\r\nABM54\r\nVCAB3\r\nVCAB4\r\nVCAB5\r\nVCABM3\r\nVCABM4\r\nVCABM5\r\nVCABM\r\n","category":"page"},{"location":"nonstiff/nonstiff_multistep/#OrdinaryDiffEq.ABM32","page":"Multistep Methods for Non-Stiff Equations","title":"OrdinaryDiffEq.ABM32","text":"E. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\nABM32: Adams-Bashforth Explicit Method   It is third order method. In ABM32, AB3 works as predictor and Adams Moulton 2-steps method works as Corrector.   Ralston's Second Order Method is used to calculate starting values.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/nonstiff_multistep/#OrdinaryDiffEq.ABM43","page":"Multistep Methods for Non-Stiff Equations","title":"OrdinaryDiffEq.ABM43","text":"E. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\nABM43: Adams-Bashforth Explicit Method   It is fourth order method. In ABM43, AB4 works as predictor and Adams Moulton 3-steps method works as Corrector.   Runge-Kutta method of order 4 is used to calculate starting values.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/nonstiff_multistep/#OrdinaryDiffEq.ABM54","page":"Multistep Methods for Non-Stiff Equations","title":"OrdinaryDiffEq.ABM54","text":"E. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\nABM54: Adams-Bashforth Explicit Method    It is fifth order method. In ABM54, AB5 works as predictor and Adams Moulton 4-steps method works as Corrector.    Runge-Kutta method of order 4 is used to calculate starting values.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/nonstiff_multistep/#OrdinaryDiffEq.VCAB3","page":"Multistep Methods for Non-Stiff Equations","title":"OrdinaryDiffEq.VCAB3","text":"E. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\nVCAB3: Adaptive step size Adams explicit Method   The 3rd order Adams method. Bogacki-Shampine 3/2 method is used to calculate starting values.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/nonstiff_multistep/#OrdinaryDiffEq.VCAB4","page":"Multistep Methods for Non-Stiff Equations","title":"OrdinaryDiffEq.VCAB4","text":"E. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\nVCAB4: Adaptive step size Adams explicit Method   The 4th order Adams method. Runge-Kutta 4 is used to calculate starting values.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/nonstiff_multistep/#OrdinaryDiffEq.VCAB5","page":"Multistep Methods for Non-Stiff Equations","title":"OrdinaryDiffEq.VCAB5","text":"E. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\nVCAB5: Adaptive step size Adams explicit Method   The 5th order Adams method. Runge-Kutta 4 is used to calculate starting values.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/nonstiff_multistep/#OrdinaryDiffEq.VCABM3","page":"Multistep Methods for Non-Stiff Equations","title":"OrdinaryDiffEq.VCABM3","text":"E. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\nVCABM3: Adaptive step size Adams explicit Method   The 3rd order Adams-Moulton method. Bogacki-Shampine 3/2 method is used to calculate starting values.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/nonstiff_multistep/#OrdinaryDiffEq.VCABM4","page":"Multistep Methods for Non-Stiff Equations","title":"OrdinaryDiffEq.VCABM4","text":"E. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\nVCABM4: Adaptive step size Adams explicit Method   The 4th order Adams-Moulton method. Runge-Kutta 4 is used to calculate starting values.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/nonstiff_multistep/#OrdinaryDiffEq.VCABM5","page":"Multistep Methods for Non-Stiff Equations","title":"OrdinaryDiffEq.VCABM5","text":"E. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\nVCABM5: Adaptive step size Adams explicit Method    The 5th order Adams-Moulton method. Runge-Kutta 4 is used to calculate starting values.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/nonstiff_multistep/#OrdinaryDiffEq.VCABM","page":"Multistep Methods for Non-Stiff Equations","title":"OrdinaryDiffEq.VCABM","text":"E. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\nVCABM: Adaptive step size Adams explicit Method   An adaptive order adaptive time Adams Moulton method.   It uses an order adaptivity algorithm is derived from Shampine's DDEABM.\n\n\n\n\n\n","category":"type"},{"location":"stiff/rosenbrock/#Rosenbrock-Methods","page":"Rosenbrock Methods","title":"Rosenbrock Methods","text":"","category":"section"},{"location":"stiff/rosenbrock/#Standard-Rosenbrock-Methods","page":"Rosenbrock Methods","title":"Standard Rosenbrock Methods","text":"","category":"section"},{"location":"stiff/rosenbrock/","page":"Rosenbrock Methods","title":"Rosenbrock Methods","text":"ROS3P\r\nRodas3\r\nRosShamp4\r\nVeldd4\r\nVelds4\r\nGRK4T\r\nGRK4A\r\nRos4LStab\r\nRodas4\r\nRodas42\r\nRodas4P\r\nRodas4P2\r\nRodas5\r\nRodas5P\r\nGeneralRosenbrock","category":"page"},{"location":"stiff/rosenbrock/#Rosenbrock-W-Methods","page":"Rosenbrock Methods","title":"Rosenbrock W-Methods","text":"","category":"section"},{"location":"stiff/rosenbrock/","page":"Rosenbrock Methods","title":"Rosenbrock Methods","text":"Rosenbrock23\r\nRosenbrock32\r\nROS34PW1a\r\nROS34PW1b\r\nROS34PW2\r\nROS34PW3\r\nRosenbrockW6S4OS","category":"page"},{"location":"stiff/rosenbrock/#OrdinaryDiffEq.RosenbrockW6S4OS","page":"Rosenbrock Methods","title":"OrdinaryDiffEq.RosenbrockW6S4OS","text":"RosenbrockW6S4OS: Rosenbrock-W Method   A 4th order L-stable Rosenbrock-W method (fixed step only).\n\n\n\n\n\n","category":"type"},{"location":"dynamical/symplectic/#Symplectic-Runge-Kutta-Methods","page":"Symplectic Runge-Kutta Methods","title":"Symplectic Runge-Kutta Methods","text":"","category":"section"},{"location":"dynamical/symplectic/","page":"Symplectic Runge-Kutta Methods","title":"Symplectic Runge-Kutta Methods","text":"SymplecticEuler\r\nVelocityVerlet\r\nVerletLeapfrog\r\nPseudoVerletLeapfrog\r\nMcAte2\r\nRuth3\r\nMcAte3\r\nCandyRoz4\r\nMcAte4\r\nCalvoSanz4\r\nMcAte42\r\nMcAte5\r\nYoshida6\r\nKahanLi6\r\nMcAte8\r\nKahanLi8\r\nSofSpa10","category":"page"},{"location":"dynamical/symplectic/#OrdinaryDiffEq.VelocityVerlet","page":"Symplectic Runge-Kutta Methods","title":"OrdinaryDiffEq.VelocityVerlet","text":"@article{verlet1967computer,   title={Computer\" experiments\" on classical fluids. I. Thermodynamical properties of Lennard-Jones molecules},   author={Verlet, Loup},   journal={Physical review},   volume={159},   number={1},   pages={98},   year={1967},   publisher={APS} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/symplectic/#OrdinaryDiffEq.VerletLeapfrog","page":"Symplectic Runge-Kutta Methods","title":"OrdinaryDiffEq.VerletLeapfrog","text":"@article{verlet1967computer,   title={Computer\" experiments\" on classical fluids. I. Thermodynamical properties of Lennard-Jones molecules},   author={Verlet, Loup},   journal={Physical review},   volume={159},   number={1},   pages={98},   year={1967},   publisher={APS} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/symplectic/#OrdinaryDiffEq.PseudoVerletLeapfrog","page":"Symplectic Runge-Kutta Methods","title":"OrdinaryDiffEq.PseudoVerletLeapfrog","text":"@article{verlet1967computer,   title={Computer\" experiments\" on classical fluids. I. Thermodynamical properties of Lennard-Jones molecules},   author={Verlet, Loup},   journal={Physical review},   volume={159},   number={1},   pages={98},   year={1967},   publisher={APS} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/symplectic/#OrdinaryDiffEq.McAte2","page":"Symplectic Runge-Kutta Methods","title":"OrdinaryDiffEq.McAte2","text":"@article{mclachlan1992accuracy,   title={The accuracy of symplectic integrators},   author={McLachlan, Robert I and Atela, Pau},   journal={Nonlinearity},   volume={5},   number={2},   pages={541},   year={1992},   publisher={IOP Publishing} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/symplectic/#OrdinaryDiffEq.Ruth3","page":"Symplectic Runge-Kutta Methods","title":"OrdinaryDiffEq.Ruth3","text":"@article{ruth1983canonical,   title={A canonical integration technique},   author={Ruth, Ronald D},   journal={IEEE Trans. Nucl. Sci.},   volume={30},   number={CERN-LEP-TH-83-14},   pages={2669–2671},   year={1983} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/symplectic/#OrdinaryDiffEq.McAte3","page":"Symplectic Runge-Kutta Methods","title":"OrdinaryDiffEq.McAte3","text":"@article{mclachlan1992accuracy,   title={The accuracy of symplectic integrators},   author={McLachlan, Robert I and Atela, Pau},   journal={Nonlinearity},   volume={5},   number={2},   pages={541},   year={1992},   publisher={IOP Publishing} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/symplectic/#OrdinaryDiffEq.CandyRoz4","page":"Symplectic Runge-Kutta Methods","title":"OrdinaryDiffEq.CandyRoz4","text":"@article{candy1991symplectic,   title={A symplectic integration algorithm for separable Hamiltonian functions},   author={Candy, J and Rozmus, W},   journal={Journal of Computational Physics},   volume={92},   number={1},   pages={230–256},   year={1991},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/symplectic/#OrdinaryDiffEq.CalvoSanz4","page":"Symplectic Runge-Kutta Methods","title":"OrdinaryDiffEq.CalvoSanz4","text":"@article{sanz1993symplectic,   title={Symplectic numerical methods for Hamiltonian problems},   author={Sanz-Serna, Jes{'u}s Maria and Calvo, Mari-Paz},   journal={International Journal of Modern Physics C},   volume={4},   number={02},   pages={385–392},   year={1993},   publisher={World Scientific} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/symplectic/#OrdinaryDiffEq.McAte42","page":"Symplectic Runge-Kutta Methods","title":"OrdinaryDiffEq.McAte42","text":"@article{mclachlan1992accuracy,   title={The accuracy of symplectic integrators},   author={McLachlan, Robert I and Atela, Pau},   journal={Nonlinearity},   volume={5},   number={2},   pages={541},   year={1992},   publisher={IOP Publishing} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/symplectic/#OrdinaryDiffEq.McAte5","page":"Symplectic Runge-Kutta Methods","title":"OrdinaryDiffEq.McAte5","text":"@article{mclachlan1992accuracy,   title={The accuracy of symplectic integrators},   author={McLachlan, Robert I and Atela, Pau},   journal={Nonlinearity},   volume={5},   number={2},   pages={541},   year={1992},   publisher={IOP Publishing} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/symplectic/#OrdinaryDiffEq.Yoshida6","page":"Symplectic Runge-Kutta Methods","title":"OrdinaryDiffEq.Yoshida6","text":"@article{yoshida1990construction,   title={Construction of higher order symplectic integrators},   author={Yoshida, Haruo},   journal={Physics letters A},   volume={150},   number={5-7},   pages={262–268},   year={1990},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/symplectic/#OrdinaryDiffEq.KahanLi6","page":"Symplectic Runge-Kutta Methods","title":"OrdinaryDiffEq.KahanLi6","text":"@article{kahan1997composition,   title={Composition constants for raising the orders of unconventional schemes for ordinary differential equations},   author={Kahan, William and Li, Ren-Cang},   journal={Mathematics of computation},   volume={66},   number={219},   pages={1089–1099},   year={1997} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/symplectic/#OrdinaryDiffEq.McAte8","page":"Symplectic Runge-Kutta Methods","title":"OrdinaryDiffEq.McAte8","text":"@article{mclachlan1995numerical,   title={On the numerical integration of ordinary differential equations by symmetric composition methods},   author={McLachlan, Robert I},   journal={SIAM Journal on Scientific Computing},   volume={16},   number={1},   pages={151–168},   year={1995},   publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/symplectic/#OrdinaryDiffEq.KahanLi8","page":"Symplectic Runge-Kutta Methods","title":"OrdinaryDiffEq.KahanLi8","text":"@article{kahan1997composition,   title={Composition constants for raising the orders of unconventional schemes for ordinary differential equations},   author={Kahan, William and Li, Ren-Cang},   journal={Mathematics of computation},   volume={66},   number={219},   pages={1089–1099},   year={1997} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/symplectic/#OrdinaryDiffEq.SofSpa10","page":"Symplectic Runge-Kutta Methods","title":"OrdinaryDiffEq.SofSpa10","text":"@article{sofroniou2005derivation,   title={Derivation of symmetric composition constants for symmetric integrators},   author={Sofroniou, Mark and Spaletta, Giulia},   journal={Optimization Methods and Software},   volume={20},   number={4-5},   pages={597–613},   year={2005},   publisher={Taylor \\& Francis} }\n\n\n\n\n\n","category":"type"},{"location":"misc/","page":"-","title":"-","text":"LinearExponential\r\nSplitEuler\r\nCompositeAlgorithm\r\nPDIRK44","category":"page"},{"location":"misc/#OrdinaryDiffEq.PDIRK44","page":"-","title":"OrdinaryDiffEq.PDIRK44","text":"PDIRK44: Parallel Diagonally Implicit Runge-Kutta Method   A 2 processor 4th order diagonally non-adaptive implicit method.\n\n\n\n\n\n","category":"type"},{"location":"stiff/firk/#Fully-Implicit-Runge-Kutta-(FIRK)-Methods","page":"Fully Implicit Runge-Kutta (FIRK) Methods","title":"Fully Implicit Runge-Kutta (FIRK) Methods","text":"","category":"section"},{"location":"stiff/firk/","page":"Fully Implicit Runge-Kutta (FIRK) Methods","title":"Fully Implicit Runge-Kutta (FIRK) Methods","text":"RadauIIA3\r\nRadauIIA5","category":"page"},{"location":"stiff/firk/#OrdinaryDiffEq.RadauIIA3","page":"Fully Implicit Runge-Kutta (FIRK) Methods","title":"OrdinaryDiffEq.RadauIIA3","text":"@article{hairer1999stiff,   title={Stiff differential equations solved by Radau methods},   author={Hairer, Ernst and Wanner, Gerhard},   journal={Journal of Computational and Applied Mathematics},   volume={111},   number={1-2},   pages={93–111},   year={1999},   publisher={Elsevier} }\n\nRadauIIA3: Fully-Implicit Runge-Kutta Method   An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency.\n\n\n\n\n\n","category":"type"},{"location":"stiff/firk/#OrdinaryDiffEq.RadauIIA5","page":"Fully Implicit Runge-Kutta (FIRK) Methods","title":"OrdinaryDiffEq.RadauIIA5","text":"@article{hairer1999stiff,   title={Stiff differential equations solved by Radau methods},   author={Hairer, Ernst and Wanner, Gerhard},   journal={Journal of Computational and Applied Mathematics},   volume={111},   number={1-2},   pages={93–111},   year={1999},   publisher={Elsevier} }\n\nRadauIIA5: Fully-Implicit Runge-Kutta Method    An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicit_extrapolation/#Explicit-Extrapolation-Methods","page":"Explicit Extrapolation Methods","title":"Explicit Extrapolation Methods","text":"","category":"section"},{"location":"nonstiff/explicit_extrapolation/","page":"Explicit Extrapolation Methods","title":"Explicit Extrapolation Methods","text":"AitkenNeville\r\nExtrapolationMidpointDeuflhard\r\nExtrapolationMidpointHairerWanner","category":"page"},{"location":"nonstiff/explicit_extrapolation/#OrdinaryDiffEq.AitkenNeville","page":"Explicit Extrapolation Methods","title":"OrdinaryDiffEq.AitkenNeville","text":"AitkenNeville: Parallelized Explicit Extrapolation Method    Euler extrapolation using Aitken-Neville with the Romberg Sequence.\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicit_extrapolation/#OrdinaryDiffEq.ExtrapolationMidpointDeuflhard","page":"Explicit Extrapolation Methods","title":"OrdinaryDiffEq.ExtrapolationMidpointDeuflhard","text":"ExtrapolationMidpointDeuflhard: Parallelized Explicit Extrapolation Method    Midpoint extrapolation using Barycentric coordinates\n\n\n\n\n\n","category":"type"},{"location":"nonstiff/explicit_extrapolation/#OrdinaryDiffEq.ExtrapolationMidpointHairerWanner","page":"Explicit Extrapolation Methods","title":"OrdinaryDiffEq.ExtrapolationMidpointHairerWanner","text":"ExtrapolationMidpointHairerWanner: Parallelized Explicit Extrapolation Method   Midpoint extrapolation using Barycentric coordinates, following Hairer's ODEX in the adaptivity behavior.\n\n\n\n\n\n","category":"type"},{"location":"imex/imex_multistep/#IMEX-Multistep-Methods","page":"IMEX Multistep Methods","title":"IMEX Multistep Methods","text":"","category":"section"},{"location":"imex/imex_multistep/","page":"IMEX Multistep Methods","title":"IMEX Multistep Methods","text":"CNAB2\r\nCNLF2\r\nSBDF\r\nSBDF2\r\nSBDF3\r\nSBDF4","category":"page"},{"location":"imex/imex_multistep/#OrdinaryDiffEq.SBDF2","page":"IMEX Multistep Methods","title":"OrdinaryDiffEq.SBDF2","text":"SBDF2(;kwargs...)\n\nThe two-step version of the IMEX multistep methods of\n\nUri M. Ascher, Steven J. Ruuth, Brian T. R. Wetton. Implicit-Explicit Methods for Time-Dependent Partial Differential Equations. Society for Industrial and Applied Mathematics. Journal on Numerical Analysis, 32(3), pp 797-823, 1995. doi: https://doi.org/10.1137/0732037\n\nSee also SBDF.\n\n\n\n\n\n","category":"function"},{"location":"imex/imex_multistep/#OrdinaryDiffEq.SBDF3","page":"IMEX Multistep Methods","title":"OrdinaryDiffEq.SBDF3","text":"SBDF3(;kwargs...)\n\nThe three-step version of the IMEX multistep methods of\n\nUri M. Ascher, Steven J. Ruuth, Brian T. R. Wetton. Implicit-Explicit Methods for Time-Dependent Partial Differential Equations. Society for Industrial and Applied Mathematics. Journal on Numerical Analysis, 32(3), pp 797-823, 1995. doi: https://doi.org/10.1137/0732037\n\nSee also SBDF.\n\n\n\n\n\n","category":"function"},{"location":"imex/imex_multistep/#OrdinaryDiffEq.SBDF4","page":"IMEX Multistep Methods","title":"OrdinaryDiffEq.SBDF4","text":"SBDF4(;kwargs...)\n\nThe four-step version of the IMEX multistep methods of\n\nUri M. Ascher, Steven J. Ruuth, Brian T. R. Wetton. Implicit-Explicit Methods for Time-Dependent Partial Differential Equations. Society for Industrial and Applied Mathematics. Journal on Numerical Analysis, 32(3), pp 797-823, 1995. doi: https://doi.org/10.1137/0732037\n\nSee also SBDF.\n\n\n\n\n\n","category":"function"},{"location":"semilinear/exponential_rk/#Exponential-Runge-Kutta-Integrators","page":"Exponential Runge-Kutta Integrators","title":"Exponential Runge-Kutta Integrators","text":"","category":"section"},{"location":"semilinear/exponential_rk/","page":"Exponential Runge-Kutta Integrators","title":"Exponential Runge-Kutta Integrators","text":"LawsonEuler\r\nNorsettEuler\r\nETD2\r\nETDRK2\r\nETDRK3\r\nETDRK4\r\nHochOst4\r\nExp4\r\nEPIRK4s3A\r\nEPIRK4s3B\r\nEPIRK5s3\r\nEXPRB53s3\r\nEPIRK5P1\r\nEPIRK5P2","category":"page"},{"location":"semilinear/exponential_rk/#OrdinaryDiffEq.ETD2","page":"Exponential Runge-Kutta Integrators","title":"OrdinaryDiffEq.ETD2","text":"ETD2: Exponential Runge-Kutta Method   Second order Exponential Time Differencing method (in development).\n\n\n\n\n\n","category":"type"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"OrdinaryDiffEq.jl is part of the SciML common interface, but can be used independently of DifferentialEquations.jl. The only requirement is that the user passes an OrdinaryDiffEq.jl algorithm to solve. For example, we can solve the ODE tutorial from the docs using the Tsit5() algorithm:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using OrdinaryDiffEq\nf(u,p,t) = 1.01*u\nu0=1/2\ntspan = (0.0,1.0)\nprob = ODEProblem(f,u0,tspan)\nsol = solve(prob,Tsit5(),reltol=1e-8,abstol=1e-8)\nusing Plots\nplot(sol,linewidth=5,title=\"Solution to the linear ODE with a thick line\",\n     xaxis=\"Time (t)\",yaxis=\"u(t) (in μm)\",label=\"My Thick Line!\") # legend=false\nplot!(sol.t, t->0.5*exp(1.01t),lw=3,ls=:dash,label=\"True Solution!\")","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"That example uses the out-of-place syntax f(u,p,t), while the inplace syntax (more efficient for systems of equations) is shown in the Lorenz example:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using OrdinaryDiffEq\nfunction lorenz(du,u,p,t)\n du[1] = 10.0(u[2]-u[1])\n du[2] = u[1]*(28.0-u[3]) - u[2]\n du[3] = u[1]*u[2] - (8/3)*u[3]\nend\nu0 = [1.0;0.0;0.0]\ntspan = (0.0,100.0)\nprob = ODEProblem(lorenz,u0,tspan)\nsol = solve(prob,Tsit5())\nusing Plots; plot(sol,vars=(1,2,3))","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Very fast static array versions can be specifically compiled to the size of your model. For example:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using OrdinaryDiffEq, StaticArrays\nfunction lorenz(u,p,t)\n SA[10.0(u[2]-u[1]),u[1]*(28.0-u[3]) - u[2],u[1]*u[2] - (8/3)*u[3]]\nend\nu0 = SA[1.0;0.0;0.0]\ntspan = (0.0,100.0)\nprob = ODEProblem(lorenz,u0,tspan)\nsol = solve(prob,Tsit5())","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For “refined ODEs”, like dynamical equations and SecondOrderODEProblems, refer to the DiffEqDocs. For example, in DiffEqTutorials.jl we show how to solve equations of motion using symplectic methods:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"function HH_acceleration(dv,v,u,p,t)\n    x,y  = u\n    dx,dy = dv\n    dv[1] = -x - 2x*y\n    dv[2] = y^2 - y -x^2\nend\ninitial_positions = [0.0,0.1]\ninitial_velocities = [0.5,0.0]\nprob = SecondOrderODEProblem(HH_acceleration,initial_velocities,initial_positions,tspan)\nsol2 = solve(prob, KahanLi8(), dt=1/10);","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Other refined forms are IMEX and semi-linear ODEs (for exponential integrators).","category":"page"},{"location":"usage/#Available-Solvers","page":"Usage","title":"Available Solvers","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"For the list of available solvers, please refer to the DifferentialEquations.jl ODE Solvers, Dynamical ODE Solvers, and the Split ODE Solvers pages.","category":"page"},{"location":"stiff/stabilized_rk/#Stabilized-Runge-Kutta-Methods-(Runge-Kutta-Chebyshev)","page":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","title":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","text":"","category":"section"},{"location":"stiff/stabilized_rk/#Explicit-Stabilized-Runge-Kutta-Methods","page":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","title":"Explicit Stabilized Runge-Kutta Methods","text":"","category":"section"},{"location":"stiff/stabilized_rk/","page":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","title":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","text":"Explicit stabilized methods utilize an upper bound on the spectral radius of the Jacobian.  Users can supply an upper bound by specifying the keyword argument eigen_est, for example","category":"page"},{"location":"stiff/stabilized_rk/","page":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","title":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","text":"`eigen_est = (integrator) -> integrator.eigen_est = upper_bound`","category":"page"},{"location":"stiff/stabilized_rk/","page":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","title":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","text":"The methods ROCK2 and ROCK4 also include keyword arguments min_stages and max_stages,  which specify upper and lower bounds on the adaptively chosen number of stages for stability. ","category":"page"},{"location":"stiff/stabilized_rk/","page":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","title":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","text":"ROCK2\r\nROCK4\r\nSERK2\r\nESERK4\r\nESERK5\r\nRKC","category":"page"},{"location":"stiff/stabilized_rk/#OrdinaryDiffEq.ROCK2","page":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","title":"OrdinaryDiffEq.ROCK2","text":"Assyr Abdulle, Alexei A. Medovikov. Second Order Chebyshev Methods based on Orthogonal Polynomials. Numerische Mathematik, 90 (1), pp 1-18, 2001. doi: https://dx.doi.org/10.1007/s002110100292\n\nROCK2: Stabilized Explicit Method.   Second order stabilized Runge-Kutta method.   Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.\n\nThis method takes optional keyword arguments min_stages, max_stages, and eigen_est.  The function eigen_est should be of the form \n\neigen_est = (integrator) -> integrator.eigen_est = upper_bound,\n\nwhere upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix. If eigen_est  is not provided, upper_bound will be estimated using the power iteration. \n\n\n\n\n\n","category":"type"},{"location":"stiff/stabilized_rk/#OrdinaryDiffEq.ROCK4","page":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","title":"OrdinaryDiffEq.ROCK4","text":"ROCK4(; min_stages = 0, max_stages = 152, eigen_est = nothing)\n\nAssyr Abdulle. Fourth Order Chebyshev Methods With Recurrence Relation. 2002 Society for Industrial and Applied Mathematics Journal on Scientific Computing, 23(6), pp 2041-2054, 2001. doi: https://doi.org/10.1137/S1064827500379549\n\nROCK4: Stabilized Explicit Method.   Fourth order stabilized Runge-Kutta method.   Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.\n\nThis method takes optional keyword arguments min_stages, max_stages, and eigen_est.  The function eigen_est should be of the form \n\neigen_est = (integrator) -> integrator.eigen_est = upper_bound,\n\nwhere upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix. If eigen_est  is not provided, upper_bound will be estimated using the power iteration. \n\n\n\n\n\n","category":"type"},{"location":"stiff/stabilized_rk/#OrdinaryDiffEq.ESERK4","page":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","title":"OrdinaryDiffEq.ESERK4","text":"ESERK4(; eigen_est = nothing)\n\nJ. Martín-Vaquero, B. Kleefeld. Extrapolated stabilized explicit Runge-Kutta methods,    Journal of Computational Physics, 326, pp 141-155, 2016. doi:   https://doi.org/10.1016/j.jcp.2016.08.042.\n\nESERK4: Stabilized Explicit Method.   Fourth order extrapolated stabilized Runge-Kutta method.     Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.\n\nThis method takes the keyword argument eigen_est of the form \n\neigen_est = (integrator) -> integrator.eigen_est = upper_bound,\n\nwhere upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.  If eigen_est is not provided, upper_bound will be estimated using the power iteration. \n\n\n\n\n\n","category":"type"},{"location":"stiff/stabilized_rk/#OrdinaryDiffEq.ESERK5","page":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","title":"OrdinaryDiffEq.ESERK5","text":"ESERK5(; eigen_est = nothing)\n\nJ. Martín-Vaquero, A. Kleefeld. ESERK5: A fifth-order extrapolated stabilized explicit Runge-Kutta method,   Journal of Computational and Applied Mathematics, 356, pp 22-36, 2019. doi:   https://doi.org/10.1016/j.cam.2019.01.040.\n\nESERK5: Stabilized Explicit Method.   Fifth order extrapolated stabilized Runge-Kutta method.     Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.\n\nThis method takes the keyword argument eigen_est of the form \n\neigen_est = (integrator) -> integrator.eigen_est = upper_bound,\n\nwhere upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.  If eigen_est is not provided, upper_bound will be estimated using the power iteration. \n\n\n\n\n\n","category":"type"},{"location":"stiff/stabilized_rk/#OrdinaryDiffEq.RKC","page":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","title":"OrdinaryDiffEq.RKC","text":"RKC(; eigen_est = nothing)\n\nB. P. Sommeijer, L. F. Shampine, J. G. Verwer. RKC: An Explicit Solver for Parabolic PDEs,   Journal of Computational and Applied Mathematics, 88(2), pp 315-326, 1998. doi:   https://doi.org/10.1016/S0377-0427(97)00219-7\n\nRKC: Stabilized Explicit Method.   Second order stabilized Runge-Kutta method.   Exhibits high stability for real eigenvalues. \n\nThis method takes the keyword argument eigen_est of the form   \n\neigen_est = (integrator) -> integrator.eigen_est = upper_bound,\n\nwhere upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix. If eigen_est  is not provided, upper_bound will be estimated using the power iteration. \n\n\n\n\n\n","category":"type"},{"location":"stiff/stabilized_rk/#Implicit-Stabilized-Runge-Kutta-Methods","page":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","title":"Implicit Stabilized Runge-Kutta Methods","text":"","category":"section"},{"location":"stiff/stabilized_rk/","page":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","title":"Stabilized Runge-Kutta Methods (Runge-Kutta-Chebyshev)","text":"IRKC","category":"page"},{"location":"dynamical/nystrom/#Runge-Kutta-Nystrom-Methods","page":"Runge-Kutta Nystrom Methods","title":"Runge-Kutta Nystrom Methods","text":"","category":"section"},{"location":"dynamical/nystrom/","page":"Runge-Kutta Nystrom Methods","title":"Runge-Kutta Nystrom Methods","text":"IRKN3\r\nIRKN4\r\nNystrom4\r\nNystrom4VelocityIndependent\r\nNystrom5VelocityIndependent\r\nFineRKN4\r\nFineRKN5\r\nDPRKN6\r\nDPRKN6FM\r\nDPRKN8\r\nDPRKN12\r\nERKN4\r\nERKN5\r\nERKN7","category":"page"},{"location":"dynamical/nystrom/#OrdinaryDiffEq.IRKN3","page":"Runge-Kutta Nystrom Methods","title":"OrdinaryDiffEq.IRKN3","text":"IRKN3\n\nImproved Runge-Kutta-Nyström method of order three, which minimizes the amount of evaluated functions in each step. Fixed time steps only.\n\nSecond order ODE should not depend on the first derivative.\n\nReferences\n\n@article{rabiei2012numerical,   title={Numerical Solution of Second-Order Ordinary Differential Equations by Improved Runge-Kutta Nystrom Method},   author={Rabiei, Faranak and Ismail, Fudziah and Norazak, S and Emadi, Saeid},   publisher={Citeseer} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/nystrom/#OrdinaryDiffEq.IRKN4","page":"Runge-Kutta Nystrom Methods","title":"OrdinaryDiffEq.IRKN4","text":"IRKN4\n\nImproves Runge-Kutta-Nyström method of order four, which minimizes the amount of evaluated functions in each step. Fixed time steps only.\n\nSecond order ODE should not be dependent on the first derivative.\n\nRecommended for smooth problems with expensive functions to evaluate.\n\nReferences\n\n@article{rabiei2012numerical,   title={Numerical Solution of Second-Order Ordinary Differential Equations by Improved Runge-Kutta Nystrom Method},   author={Rabiei, Faranak and Ismail, Fudziah and Norazak, S and Emadi, Saeid},   publisher={Citeseer} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/nystrom/#OrdinaryDiffEq.Nystrom4","page":"Runge-Kutta Nystrom Methods","title":"OrdinaryDiffEq.Nystrom4","text":"Nystrom4\n\nA 4th order explicit Runge-Kutta-Nyström method which can be applied directly on second order ODEs. Can only be used with fixed time steps.\n\nIn case the ODE Problem is not dependent on the first derivative consider using  Nystrom4VelocityIndependent to increase performance.\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I.   Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics,   Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"dynamical/nystrom/#OrdinaryDiffEq.Nystrom4VelocityIndependent","page":"Runge-Kutta Nystrom Methods","title":"OrdinaryDiffEq.Nystrom4VelocityIndependent","text":"Nystrom4VelocityIdependent\n\nA 4th order explicit Runkge-Kutta-Nyström method. Used directly on second order ODEs, where the acceleration is independent from velocity (ODE Problem is not dependent on the first derivative).\n\nMore efficient then Nystrom4 on velocity independent problems, since less evaluations are needed.\n\nFixed time steps only.\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I.   Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics,   Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"dynamical/nystrom/#OrdinaryDiffEq.Nystrom5VelocityIndependent","page":"Runge-Kutta Nystrom Methods","title":"OrdinaryDiffEq.Nystrom5VelocityIndependent","text":"Nystrom5VelocityIndependent\n\nA 5th order explicit Runkge-Kutta-Nyström method. Used directly on second order ODEs, where the acceleration is independent from velocity (ODE Problem is not dependent on the first derivative). Fixed time steps only.\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I.   Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics,   Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"dynamical/nystrom/#OrdinaryDiffEq.FineRKN4","page":"Runge-Kutta Nystrom Methods","title":"OrdinaryDiffEq.FineRKN4","text":"FineRKN4()\n\nA 4th order explicit Runge-Kutta-Nyström method which can be applied directly to second order ODEs. In particular, this method allows the acceleration equation to depend on the velocity.\n\nReferences\n\n@article{fine1987low,\n  title={Low order practical {R}unge-{K}utta-{N}ystr{\"o}m methods},\n  author={Fine, Jerry Michael},\n  journal={Computing},\n  volume={38},\n  number={4},\n  pages={281--297},\n  year={1987},\n  publisher={Springer}\n}\n\n\n\n\n\n","category":"type"},{"location":"dynamical/nystrom/#OrdinaryDiffEq.FineRKN5","page":"Runge-Kutta Nystrom Methods","title":"OrdinaryDiffEq.FineRKN5","text":"FineRKN5()\n\nA 5th order explicit Runge-Kutta-Nyström method which can be applied directly to second order ODEs. In particular, this method allows the acceleration equation to depend on the velocity.\n\nReferences\n\n@article{fine1987low,\n  title={Low order practical {R}unge-{K}utta-{N}ystr{\"o}m methods},\n  author={Fine, Jerry Michael},\n  journal={Computing},\n  volume={38},\n  number={4},\n  pages={281--297},\n  year={1987},\n  publisher={Springer}\n}\n\n\n\n\n\n","category":"type"},{"location":"dynamical/nystrom/#OrdinaryDiffEq.DPRKN6","page":"Runge-Kutta Nystrom Methods","title":"OrdinaryDiffEq.DPRKN6","text":"DPRKN6\n\n6th order explicit Runge-Kutta-Nyström method. The second order ODE should not depend on the first derivative. Free 6th order interpolant.\n\nReferences\n\n@article{dormand1987runge,   title={Runge-kutta-nystrom triples},   author={Dormand, JR and Prince, PJ},   journal={Computers \\& Mathematics with Applications},   volume={13},   number={12},   pages={937–949},   year={1987},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/nystrom/#OrdinaryDiffEq.DPRKN6FM","page":"Runge-Kutta Nystrom Methods","title":"OrdinaryDiffEq.DPRKN6FM","text":"DPRKN6FM\n\n6th order explicit Runge-Kutta-Nyström method. The second order ODE should not depend on the first derivative.\n\nCompared to DPRKN6, this method has smaller truncation error coefficients which leads to performance gain when only the main solution points are considered.\n\nReferences\n\n@article{Dormand1987FamiliesOR,   title={Families of Runge-Kutta-Nystrom Formulae},   author={J. R. Dormand and Moawwad E. A. El-Mikkawy and P. J. Prince},   journal={Ima Journal of Numerical Analysis},   year={1987},   volume={7},   pages={235-250} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/nystrom/#OrdinaryDiffEq.DPRKN8","page":"Runge-Kutta Nystrom Methods","title":"OrdinaryDiffEq.DPRKN8","text":"DPRKN8\n\n8th order explicit Runge-Kutta-Nyström method. The second order ODE should not depend on the first derivative.\n\nNot as efficient as DPRKN12 when high accuracy is needed, however this solver is competitive with DPRKN6 at lax tolerances and, depending on the problem, might be a good option between performance and accuracy.\n\nReferences\n\n@article{dormand1987high,   title={High-order embedded Runge-Kutta-Nystrom formulae},   author={Dormand, JR and El-Mikkawy, MEA and Prince, PJ},   journal={IMA Journal of Numerical Analysis},   volume={7},   number={4},   pages={423–430},   year={1987},   publisher={Oxford University Press} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/nystrom/#OrdinaryDiffEq.DPRKN12","page":"Runge-Kutta Nystrom Methods","title":"OrdinaryDiffEq.DPRKN12","text":"DPRKN12\n\n12th order explicit Rugne-Kutta-Nyström method. The second order ODE should not depend on the first derivative.\n\nMost efficient when high accuracy is needed.\n\nReferences\n\n@article{dormand1987high,   title={High-order embedded Runge-Kutta-Nystrom formulae},   author={Dormand, JR and El-Mikkawy, MEA and Prince, PJ},   journal={IMA Journal of Numerical Analysis},   volume={7},   number={4},   pages={423–430},   year={1987},   publisher={Oxford University Press} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/nystrom/#OrdinaryDiffEq.ERKN4","page":"Runge-Kutta Nystrom Methods","title":"OrdinaryDiffEq.ERKN4","text":"ERKN4\n\nEmbedded 4(3) pair of explicit Runge-Kutta-Nyström methods. Integrates the periodic properties of the harmonic oscillator exactly.\n\nThe second order ODE should not depend on the first derivative.\n\nUses adaptive step size control. This method is extra efficient on periodic problems.\n\nReferences\n\n@article{demba2017embedded,   title={An Embedded 4 (3) Pair of Explicit Trigonometrically-Fitted Runge-Kutta-Nystr{\"o}m Method for Solving Periodic Initial Value Problems},   author={Demba, MA and Senu, N and Ismail, F},   journal={Applied Mathematical Sciences},   volume={11},   number={17},   pages={819–838},   year={2017} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/nystrom/#OrdinaryDiffEq.ERKN5","page":"Runge-Kutta Nystrom Methods","title":"OrdinaryDiffEq.ERKN5","text":"ERKN5\n\nEmbedded 5(4) pair of explicit Runge-Kutta-Nyström methods. Integrates the periodic properties of the harmonic oscillator exactly.\n\nThe second order ODE should not depend on the first derivative.\n\nUses adaptive step size control. This method is extra efficient on periodic problems.\n\nReferences\n\n@article{demba20165,   title={A 5 (4) Embedded Pair of Explicit Trigonometrically-Fitted Runge–Kutta–Nystr{\"o}m Methods for the Numerical Solution of Oscillatory Initial Value Problems},   author={Demba, Musa A and Senu, Norazak and Ismail, Fudziah},   journal={Mathematical and Computational Applications},   volume={21},   number={4},   pages={46},   year={2016},   publisher={Multidisciplinary Digital Publishing Institute} }\n\n\n\n\n\n","category":"type"},{"location":"dynamical/nystrom/#OrdinaryDiffEq.ERKN7","page":"Runge-Kutta Nystrom Methods","title":"OrdinaryDiffEq.ERKN7","text":"ERKN7\n\nEmbedded pair of explicit Runge-Kutta-Nyström methods. Integrates the periodic properties of the harmonic oscillator exactly.\n\nThe second order ODE should not depend on the first derivative.\n\nUses adaptive step size control. This method is extra efficient on periodic Problems.\n\nReferences\n\n@article{SimosOnHO,   title={On high order Runge-Kutta-Nystr{\"o}m pairs},   author={Theodore E. Simos and Ch. Tsitouras},   journal={J. Comput. Appl. Math.},   volume={400},   pages={113753} }\n\n\n\n\n\n","category":"type"},{"location":"stiff/implicit_extrapolation/#Implicit-Extrapolation-Methods","page":"Implicit Extrapolation Methods","title":"Implicit Extrapolation Methods","text":"","category":"section"},{"location":"stiff/implicit_extrapolation/","page":"Implicit Extrapolation Methods","title":"Implicit Extrapolation Methods","text":"ImplicitEulerExtrapolation\r\nImplicitDeuflhardExtrapolation\r\nImplicitHairerWannerExtrapolation\r\nImplicitEulerBarycentricExtrapolation","category":"page"},{"location":"stiff/implicit_extrapolation/#OrdinaryDiffEq.ImplicitEulerExtrapolation","page":"Implicit Extrapolation Methods","title":"OrdinaryDiffEq.ImplicitEulerExtrapolation","text":"ImplicitEulerExtrapolation: Parallelized Implicit Extrapolation Method    Extrapolation of implicit Euler method with Romberg sequence.    Similar to Hairer's SEULEX.\n\n\n\n\n\n","category":"type"},{"location":"stiff/implicit_extrapolation/#OrdinaryDiffEq.ImplicitDeuflhardExtrapolation","page":"Implicit Extrapolation Methods","title":"OrdinaryDiffEq.ImplicitDeuflhardExtrapolation","text":"ImplicitDeuflhardExtrapolation: Parallelized Implicit Extrapolation Method    Midpoint extrapolation using Barycentric coordinates\n\n\n\n\n\n","category":"type"},{"location":"stiff/implicit_extrapolation/#OrdinaryDiffEq.ImplicitHairerWannerExtrapolation","page":"Implicit Extrapolation Methods","title":"OrdinaryDiffEq.ImplicitHairerWannerExtrapolation","text":"ImplicitHairerWannerExtrapolation: Parallelized Implicit Extrapolation Method   Midpoint extrapolation using Barycentric coordinates, following Hairer's SODEX in the adaptivity behavior.\n\n\n\n\n\n","category":"type"},{"location":"stiff/implicit_extrapolation/#OrdinaryDiffEq.ImplicitEulerBarycentricExtrapolation","page":"Implicit Extrapolation Methods","title":"OrdinaryDiffEq.ImplicitEulerBarycentricExtrapolation","text":"ImplicitEulerBarycentricExtrapolation: Parallelized Implicit Extrapolation Method   Euler extrapolation using Barycentric coordinates, following Hairer's SODEX in the adaptivity behavior.\n\n\n\n\n\n","category":"type"},{"location":"imex/imex_sdirk/#IMEX-SDIRK-Methods","page":"IMEX SDIRK Methods","title":"IMEX SDIRK Methods","text":"","category":"section"},{"location":"imex/imex_sdirk/","page":"IMEX SDIRK Methods","title":"IMEX SDIRK Methods","text":"IMEXEuler\r\nIMEXEulerARK\r\nKenCarp3\r\nKenCarp4\r\nKenCarp47\r\nKenCarp5\r\nKenCarp58\r\nESDIRK54I8L2SA\r\nESDIRK436L2SA2\r\nESDIRK437L2SA\r\nESDIRK547L2SA2\r\nESDIRK659L2SA","category":"page"},{"location":"imex/imex_sdirk/#OrdinaryDiffEq.IMEXEuler","page":"IMEX SDIRK Methods","title":"OrdinaryDiffEq.IMEXEuler","text":"IMEXEuler(;kwargs...)\n\nThe one-step version of the IMEX multistep methods of\n\nUri M. Ascher, Steven J. Ruuth, Brian T. R. Wetton. Implicit-Explicit Methods for Time-Dependent Partial Differential Equations. Society for Industrial and Applied Mathematics. Journal on Numerical Analysis, 32(3), pp 797-823, 1995. doi: https://doi.org/10.1137/0732037\n\nWhen applied to a SplitODEProblem of the form\n\nu'(t) = f1(u) + f2(u)\n\nThe default IMEXEuler() method uses an update of the form\n\nunew = uold + dt * (f1(unew) + f2(uold))\n\nSee also SBDF, IMEXEulerARK.\n\n\n\n\n\n","category":"function"},{"location":"imex/imex_sdirk/#OrdinaryDiffEq.IMEXEulerARK","page":"IMEX SDIRK Methods","title":"OrdinaryDiffEq.IMEXEulerARK","text":"IMEXEulerARK(;kwargs...)\n\nThe one-step version of the IMEX multistep methods of\n\nUri M. Ascher, Steven J. Ruuth, Brian T. R. Wetton. Implicit-Explicit Methods for Time-Dependent Partial Differential Equations. Society for Industrial and Applied Mathematics. Journal on Numerical Analysis, 32(3), pp 797-823, 1995. doi: https://doi.org/10.1137/0732037\n\nWhen applied to a SplitODEProblem of the form\n\nu'(t) = f1(u) + f2(u)\n\nA classical additive Runge-Kutta method in the sense of Araújo, Murua, Sanz-Serna (1997) consisting of the implicit and the explicit Euler method given by\n\ny1   = uold + dt * f1(y1)\nunew = uold + dt * (f1(unew) + f2(y1))\n\nSee also SBDF, IMEXEuler.\n\n\n\n\n\n","category":"function"},{"location":"imex/imex_sdirk/#OrdinaryDiffEq.KenCarp3","page":"IMEX SDIRK Methods","title":"OrdinaryDiffEq.KenCarp3","text":"@book{kennedy2001additive,   title={Additive Runge-Kutta schemes for convection-diffusion-reaction equations},   author={Kennedy, Christopher Alan},   year={2001},   publisher={National Aeronautics and Space Administration, Langley Research Center} }\n\nKenCarp3: SDIRK Method   An A-L stable stiffly-accurate 3rd order ESDIRK method with splitting\n\n\n\n\n\n","category":"type"},{"location":"imex/imex_sdirk/#OrdinaryDiffEq.KenCarp4","page":"IMEX SDIRK Methods","title":"OrdinaryDiffEq.KenCarp4","text":"@book{kennedy2001additive,   title={Additive Runge-Kutta schemes for convection-diffusion-reaction equations},   author={Kennedy, Christopher Alan},   year={2001},   publisher={National Aeronautics and Space Administration, Langley Research Center} }\n\nKenCarp4: SDIRK Method   An A-L stable stiffly-accurate 4th order ESDIRK method with splitting\n\n\n\n\n\n","category":"type"},{"location":"imex/imex_sdirk/#OrdinaryDiffEq.KenCarp47","page":"IMEX SDIRK Methods","title":"OrdinaryDiffEq.KenCarp47","text":"@article{kennedy2019higher,   title={Higher-order additive Runge–Kutta schemes for ordinary differential equations},   author={Kennedy, Christopher A and Carpenter, Mark H},   journal={Applied Numerical Mathematics},   volume={136},   pages={183–205},   year={2019},   publisher={Elsevier} }\n\nKenCarp47: SDIRK Method   An A-L stable stiffly-accurate 4th order seven-stage ESDIRK method with splitting\n\n\n\n\n\n","category":"type"},{"location":"imex/imex_sdirk/#OrdinaryDiffEq.KenCarp5","page":"IMEX SDIRK Methods","title":"OrdinaryDiffEq.KenCarp5","text":"@book{kennedy2001additive,   title={Additive Runge-Kutta schemes for convection-diffusion-reaction equations},   author={Kennedy, Christopher Alan},   year={2001},   publisher={National Aeronautics and Space Administration, Langley Research Center} }\n\nKenCarp5: SDIRK Method   An A-L stable stiffly-accurate 5th order ESDIRK method with splitting\n\n\n\n\n\n","category":"type"},{"location":"imex/imex_sdirk/#OrdinaryDiffEq.KenCarp58","page":"IMEX SDIRK Methods","title":"OrdinaryDiffEq.KenCarp58","text":"@article{kennedy2019higher,   title={Higher-order additive Runge–Kutta schemes for ordinary differential equations},   author={Kennedy, Christopher A and Carpenter, Mark H},   journal={Applied Numerical Mathematics},   volume={136},   pages={183–205},   year={2019},   publisher={Elsevier} }\n\nKenCarp58: SDIRK Method   An A-L stable stiffly-accurate 5th order eight-stage ESDIRK method with splitting\n\n\n\n\n\n","category":"type"},{"location":"imex/imex_sdirk/#OrdinaryDiffEq.ESDIRK436L2SA2","page":"IMEX SDIRK Methods","title":"OrdinaryDiffEq.ESDIRK436L2SA2","text":"@article{Kennedy2019DiagonallyIR,   title={Diagonally implicit Runge–Kutta methods for stiff ODEs},   author={Christopher A. Kennedy and Mark H. Carpenter},   journal={Applied Numerical Mathematics},   year={2019},   volume={146},   pages={221-244} }\n\n\n\n\n\n","category":"type"},{"location":"imex/imex_sdirk/#OrdinaryDiffEq.ESDIRK437L2SA","page":"IMEX SDIRK Methods","title":"OrdinaryDiffEq.ESDIRK437L2SA","text":"@article{Kennedy2019DiagonallyIR,   title={Diagonally implicit Runge–Kutta methods for stiff ODEs},   author={Christopher A. Kennedy and Mark H. Carpenter},   journal={Applied Numerical Mathematics},   year={2019},   volume={146},   pages={221-244} }\n\n\n\n\n\n","category":"type"},{"location":"imex/imex_sdirk/#OrdinaryDiffEq.ESDIRK547L2SA2","page":"IMEX SDIRK Methods","title":"OrdinaryDiffEq.ESDIRK547L2SA2","text":"@article{Kennedy2019DiagonallyIR,   title={Diagonally implicit Runge–Kutta methods for stiff ODEs},   author={Christopher A. Kennedy and Mark H. Carpenter},   journal={Applied Numerical Mathematics},   year={2019},   volume={146},   pages={221-244} }\n\n\n\n\n\n","category":"type"},{"location":"imex/imex_sdirk/#OrdinaryDiffEq.ESDIRK659L2SA","page":"IMEX SDIRK Methods","title":"OrdinaryDiffEq.ESDIRK659L2SA","text":"@article{Kennedy2019DiagonallyIR,   title={Diagonally implicit Runge–Kutta methods for stiff ODEs},   author={Christopher A. Kennedy and Mark H. Carpenter},   journal={Applied Numerical Mathematics},   year={2019},   volume={146},   pages={221-244}\n\nCurrently has STABILITY ISSUES, causing it to fail the adaptive tests.   Check issue https://github.com/SciML/OrdinaryDiffEq.jl/issues/1933 for more details. }\n\n\n\n\n\n","category":"type"},{"location":"#OrdinaryDiffEq.jl","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl","text":"","category":"section"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"OrdinaryDiffEq.jl is a component package in the DifferentialEquations ecosystem. It holds the ordinary differential equation solvers and utilities. While completely independent and usable on its own, users interested in using this functionality should check out DifferentialEquations.jl.","category":"page"},{"location":"#Installation","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"Installation","text":"","category":"section"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"Assuming that you already have Julia correctly installed, it suffices to import OrdinaryDiffEq.jl in the standard way:","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"import Pkg; Pkg.add(\"OrdinaryDiffEq\")","category":"page"},{"location":"#Reproducibility","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"</details>","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"</details>","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"using Pkg # hide\nPkg.status(;mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"</details>","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"You can also download the \n<a href=\"","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Manifest.toml\"","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"\">manifest</a> file and the\n<a href=\"","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Project.toml\"","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"\">project</a> file.","category":"page"},{"location":"stiff/sdirk/#Singly-Diagonally-Implicit-Runge-Kutta-(SDIRK)-Methods","page":"Singly-Diagonally Implicit Runge-Kutta (SDIRK) Methods","title":"Singly-Diagonally Implicit Runge-Kutta (SDIRK) Methods","text":"","category":"section"},{"location":"stiff/sdirk/","page":"Singly-Diagonally Implicit Runge-Kutta (SDIRK) Methods","title":"Singly-Diagonally Implicit Runge-Kutta (SDIRK) Methods","text":"ImplicitEuler\r\nImplicitMidpoint\r\nTrapezoid\r\nTRBDF2\r\nSDIRK2\r\nSDIRK22\r\nSSPSDIRK2\r\nKvaerno3\r\nCFNLIRK3\r\nCash4\r\nSFSDIRK4\r\nSFSDIRK5\r\nSFSDIRK6\r\nSFSDIRK7\r\nSFSDIRK8\r\nHairer4\r\nHairer42\r\nKvaerno4\r\nKvaerno5","category":"page"},{"location":"stiff/sdirk/#OrdinaryDiffEq.ImplicitEuler","page":"Singly-Diagonally Implicit Runge-Kutta (SDIRK) Methods","title":"OrdinaryDiffEq.ImplicitEuler","text":"ImplicitEuler: SDIRK Method   A 1st order implicit solver. A-B-L-stable. Adaptive timestepping through a divided differences estimate via memory.   Strong-stability preserving (SSP).\n\n\n\n\n\n","category":"type"},{"location":"stiff/sdirk/#OrdinaryDiffEq.ImplicitMidpoint","page":"Singly-Diagonally Implicit Runge-Kutta (SDIRK) Methods","title":"OrdinaryDiffEq.ImplicitMidpoint","text":"ImplicitMidpoint: SDIRK Method   A second order A-stable symplectic and symmetric implicit solver.   Good for highly stiff equations which need symplectic integration.\n\n\n\n\n\n","category":"type"},{"location":"stiff/sdirk/#OrdinaryDiffEq.Trapezoid","page":"Singly-Diagonally Implicit Runge-Kutta (SDIRK) Methods","title":"OrdinaryDiffEq.Trapezoid","text":"Andre Vladimirescu. 1994. The Spice Book. John Wiley & Sons, Inc., New York,   NY, USA.\n\nTrapezoid: SDIRK Method A second order A-stable symmetric ESDIRK method. \"Almost symplectic\" without numerical dampening.  Also known as Crank-Nicolson when applied to PDEs. Adaptive timestepping via divided differences approximation to the second derivative terms in the local truncation error estimate (the SPICE approximation strategy).\n\n\n\n\n\n","category":"type"},{"location":"stiff/sdirk/#OrdinaryDiffEq.TRBDF2","page":"Singly-Diagonally Implicit Runge-Kutta (SDIRK) Methods","title":"OrdinaryDiffEq.TRBDF2","text":"@article{hosea1996analysis,   title={Analysis and implementation of TR-BDF2},   author={Hosea, ME and Shampine, LF},   journal={Applied Numerical Mathematics},   volume={20},   number={1-2},   pages={21–37},   year={1996},   publisher={Elsevier} }\n\nTRBDF2: SDIRK Method   A second order A-B-L-S-stable one-step ESDIRK method.   Includes stiffness-robust error estimates for accurate adaptive timestepping, smoothed derivatives for highly stiff and oscillatory problems.\n\n\n\n\n\n","category":"type"},{"location":"stiff/sdirk/#OrdinaryDiffEq.SDIRK2","page":"Singly-Diagonally Implicit Runge-Kutta (SDIRK) Methods","title":"OrdinaryDiffEq.SDIRK2","text":"@article{hindmarsh2005sundials,   title={{SUNDIALS}: Suite of nonlinear and differential/algebraic equation solvers},   author={Hindmarsh, Alan C and Brown, Peter N and Grant, Keith E and Lee, Steven L and Serban, Radu and Shumaker, Dan E and Woodward, Carol S},   journal={ACM Transactions on Mathematical Software (TOMS)},   volume={31},   number={3},   pages={363–396},   year={2005},   publisher={ACM} }\n\nSDIRK2: SDIRK Method    An A-B-L stable 2nd order SDIRK method\n\n\n\n\n\n","category":"type"},{"location":"stiff/sdirk/#OrdinaryDiffEq.Kvaerno3","page":"Singly-Diagonally Implicit Runge-Kutta (SDIRK) Methods","title":"OrdinaryDiffEq.Kvaerno3","text":"@article{kvaerno2004singly,   title={Singly diagonally implicit Runge–Kutta methods with an explicit first stage},   author={Kv{\\ae}rn{\\o}, Anne},   journal={BIT Numerical Mathematics},   volume={44},   number={3},   pages={489–502},   year={2004},   publisher={Springer} }\n\nKvaerno3: SDIRK Method   An A-L stable stiffly-accurate 3rd order ESDIRK method\n\n\n\n\n\n","category":"type"},{"location":"stiff/sdirk/#OrdinaryDiffEq.Cash4","page":"Singly-Diagonally Implicit Runge-Kutta (SDIRK) Methods","title":"OrdinaryDiffEq.Cash4","text":"@article{hindmarsh2005sundials,   title={{SUNDIALS}: Suite of nonlinear and differential/algebraic equation solvers},   author={Hindmarsh, Alan C and Brown, Peter N and Grant, Keith E and Lee, Steven L and Serban, Radu and Shumaker, Dan E and Woodward, Carol S},   journal={ACM Transactions on Mathematical Software (TOMS)},   volume={31},   number={3},   pages={363–396},   year={2005},   publisher={ACM} }\n\nCash4: SDIRK Method   An A-L stable 4th order SDIRK method\n\n\n\n\n\n","category":"type"},{"location":"stiff/sdirk/#OrdinaryDiffEq.Hairer4","page":"Singly-Diagonally Implicit Runge-Kutta (SDIRK) Methods","title":"OrdinaryDiffEq.Hairer4","text":"E. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and   differential-algebraic problems. Computational mathematics (2nd revised ed.),   Springer (1996)\n\nHairer4: SDIRK Method   An A-L stable 4th order SDIRK method\n\n\n\n\n\n","category":"type"},{"location":"stiff/sdirk/#OrdinaryDiffEq.Hairer42","page":"Singly-Diagonally Implicit Runge-Kutta (SDIRK) Methods","title":"OrdinaryDiffEq.Hairer42","text":"E. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and   differential-algebraic problems. Computational mathematics (2nd revised ed.),   Springer (1996)\n\nHairer42: SDIRK Method   An A-L stable 4th order SDIRK method\n\n\n\n\n\n","category":"type"},{"location":"stiff/sdirk/#OrdinaryDiffEq.Kvaerno4","page":"Singly-Diagonally Implicit Runge-Kutta (SDIRK) Methods","title":"OrdinaryDiffEq.Kvaerno4","text":"@article{kvaerno2004singly,   title={Singly diagonally implicit Runge–Kutta methods with an explicit first stage},   author={Kv{\\ae}rn{\\o}, Anne},   journal={BIT Numerical Mathematics},   volume={44},   number={3},   pages={489–502},   year={2004},   publisher={Springer} }\n\nKvaerno4: SDIRK Method   An A-L stable stiffly-accurate 4th order ESDIRK method.\n\n\n\n\n\n","category":"type"},{"location":"stiff/sdirk/#OrdinaryDiffEq.Kvaerno5","page":"Singly-Diagonally Implicit Runge-Kutta (SDIRK) Methods","title":"OrdinaryDiffEq.Kvaerno5","text":"@article{kvaerno2004singly,   title={Singly diagonally implicit Runge–Kutta methods with an explicit first stage},   author={Kv{\\ae}rn{\\o}, Anne},   journal={BIT Numerical Mathematics},   volume={44},   number={3},   pages={489–502},   year={2004},   publisher={Springer} }\n\nKvaerno5: SDIRK Method   An A-L stable stiffly-accurate 5th order ESDIRK method\n\n\n\n\n\n","category":"type"}]
}
